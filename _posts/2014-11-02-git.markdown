---
layout: post
cover: 'assets/images/cover11.jpeg'
navigation: True
title: "Git 学习之路"
date: 2014-11-02 23:46:31 +0800
comments: true
tags: IT
subclass: 'post tag-speeches'
logo: 'assets/images/ghost.png'
author: yiming
categories: yiming
description: "本文章常用的 Git 命令罗列一下，便于查找。"
---

本文章常用的 Git 命令罗列一下，便于查找。

本文主要参考 [GitHub Git Cheat Sheet](https://training.github.com/kit/downloads/github-git-cheat-sheet.pdf)。如果你想系统的学习 Git，你可以阅读[官方中文文档](http://git-scm.com/doc),可以从这里下载 [中文 Pro Git epub 下载地址](http://pan.baidu.com/s/1c0xUk3e)。后续学到内容，会在本文章里更新。  

![Git](/images/Git/0.png)

# 开始

## 介绍

在 Git 内部有 3 中状态：

- 已修改
- 已暂存（``git add .``）
- 已提交 (``git commit -m 'XXX'``)

已修改表示修改了某个文件，但是还没有暂存。  
已暂存表示把已修改的文件放在下次提交时要保存的清单中。  
已提交表示该文件已经被安全地保存在本地数据库中了。  

基本的 Git 工作流程如下：

1.在工作目录中修改某文件（修改）
2.对这些修改了的文件作快照，并保存到暂存区（暂存）
3.提交更新，将保存在暂存区域的文件快照转储到 git 目录中（提交）  

## 安装

Mac OS X 上已经自带 Git 了。

其他系统，请参考：

<https://git-scm.com/downloads>

# 配置

一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作一般只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。

## 全局配置：

配置用户名：

```
git config --global user.name 'Tom'
```

配置邮箱：

```
git config --global user.email 'Tom@163.com'
```

## 为某个文件夹单独配置

1.先进入要配置的文件夹，并初始化 git

```
cd [文件夹]
git init
```

2.配置用户名：

```
git config --local user.name 'Jerry'
```

3.配置邮箱：

```
git config --local user.email 'Jerry@163.com'
```

## 查看有户名和邮箱

```
git config user.name
git config user.email
```

注：在为某个文件夹单独配置的文件下查看，如上配置，显示用户名为 Jerry，邮箱为 Jerry@163.com。否则为全局配置，显示用户名为 Tom，邮箱为 Tom@163.com。

# 仓库

## 从当前目录初始化

```
cd [目录]

git init 
```

## 从现有仓库克隆

```
cd [目录]

git clone [仓库地址]
```

# 基础

## 前提

1.新建一个文件夹名为 test，并进入

```
mkdir test
cd test
```

2.初始化 Git

```
git init
```

3.创建文件 1.txt

```
vim 1.txt
```

1. 按 ``i`` 开始写入一些英文
2. 按 ``esc`` 键
3. 输入 ``:wq`` 退出

## git add

现在我们已经创建了文件，并添加了文本内容。也就是介绍部分所说的修改状态。现在我们要将修改添加到暂存区，就用到了 ``git add`` 命令:

```
git add 1.txt
```

备注：如果添加并修改了多个文件，不想一个个的添加到暂存区，可以使用全部添加命令：

```
git add .
```

## git commit

现在文件已经到了暂存区状态，我们如果要安全的保存在本地数据库中即提交，我们就要使用 ``git commit`` 命令：

```
git commit -m '我创建并修改了 1.txt 文件'
```

注： ``-m`` 后面文字备注了我们操作了什么。

## git diff

``git diff`` 命令使用来查看修改的但是还没暂存（``git add``）的改动。

比如我们继续修改 1.txt 文件，追加文本 ``Hello World``。使用 ``git diff`` 命令会看到：

```
diff --git a/1.txt b/1.txt
index aa1151a..20fa783 100644
--- a/1.txt
+++ b/1.txt
@@ -1 +1,3 @@
 init
+
+Hello World
```

注：若是要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用命令：

```
git diff --cached
```

## git status

与上面的 ``git diff`` 不同，``git status`` 的显示比较简单，仅仅列出了修改过的文件。

注：该命令查看的是 修改的文件 和 已暂存文件的状态。

## git log

在提交了若干更新后或是克隆了某个项目，想看提交历史，可以使用 ``git log`` 命令。

## git remote

因为上面的内容都是在本地操作，我们要链接远程仓库怎么办？ 我们使用 ``git remote`` 命令：

```
git remote add [shortname] [url]
```

比如：

```
git remote add origin git://github.com/git.git
```

## git pull

远端有代码更新时，我们使用 ``git pull`` 命令,拉取远端代码：

```
git pull origin master
```

## git push

向远端更新代码时，使用 ``git push`` 命令，

```
git push origin master
```

# 分支

## 新建分支

1.创建本地分支

```
git branch dev
```

注：默认分支为 master。``git init`` 刚开始时时没有分支的，只有提交过一次后才会出现 master 分支。切换分支使用 ``git checkout [分支名称]``。如切换到 dev 分支：

```
git checkout dev
```

2.将分支 push 到远程使用

```
git push origin [分支名称]
```

如将本地 dev 分支 push 到远程，使用：

```
git push origin dev
```

注：也可以运行:

```
git push origin dev:dev
```

来实现相同的效果，它的意思是“提取我的 dev 并更新到远程仓库的 dev”。

通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫做 remoteDev，可以用:

```
git push origin dev:remoteDev
```

## 删除分支

1.删除本地分支

```
git branch -d [分支名称]
```

比如删除本地分支 dev

```
git checkout master

git branch -d dev
```

2.删除远程分支

```
git push origin :[远程分支名称]
```

比如删除远程分支 dev:

```
git push origin :dev
```

## 跟踪分支

从远程分支检出的本地分支，成为跟踪分支。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入 ``git push``，Git 会自行推断应该向哪个拂去其的哪个分支推送数据。反过来，在这些分支里运行 ``git pull`` 会获取所有远程索引，并把它们的数据都合并到本地分支中来。

在克隆仓库时，Git 通常会自动创建一个 master 分支来跟踪 origin/master。这正是 ``git push`` 和 ``git pull`` 一开始就能正常工作的原因。

有时远程有新分支，我们需要检出，如何操作呢？两步。

1.通过 fetch 操作抓取新的远程分支

```
git fetch
```

注：可以通过 ``git branch -r`` 来查看本地抓取的远程分支。

2.检出远程新分支

```
git checkout -b [分支名] [远程名]/[分支名]
```

比如要检出远程分支 newfeature:

```
git fetch
git checkout -b newfeature origin/newfeature
```

# 储藏（stash)

当正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上记性一些工作。问题是，你不想提交进行了一般的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是 ``git stash`` 命令。

## 使用储藏

接上文，我们更改 1.txt 文件完成后，执行操作：

```
git stash
```

如果我们想备注一下储藏，更方便的知道储藏的是什么东西，可以使用：

```
git stash save "备注信息"
```

上面的命令将会把我们的修改储藏起来。

## 查看储藏列表

我们可以通过，``git stash list`` 来查看所有储藏。


## 使用某次储藏

使用最后一次储藏，可以使用：

```
git stash apply
```

```
git stash pop
```

注：apply 会使用这次储藏，但不会删除这次储藏。pop 会使用这次储藏，并删除这次储藏。

使用某次提交，可以使用：

```
git stash apply stash@{index}
```

```
git stash pop stash@{index}
```

注 ``stash@{index}`` 中的 index，是 stash 的索引。使用 ``git stash list`` 可以看到每次的储藏索引。

## 删除某次储藏

删除储藏使用：

```
git stash drop stash@{0}
```

## 清除所有储藏

```
git stash clear
```

# 合并（merge)

将 newfeature 分支 合并到 master 分支：

```
git checkout master
git merge newfeature
```
或者一句话实现:  

```
git merge newfeature master
```

有时候合并操作并不会如此书里，如果两个分支同时修改了同一个文件的同一个部分，就出现了合并冲突。

任何包含未解决冲突的文件都会以未合并状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到这样一些符号：

```
<<<<<<< HEAD:1.txt
...
=======
...
>>>>>>> newfeature:1.txt

```

``=======`` 隔开的上半部分，是 HEAD（即 master 分支）中的内容，下半部分是在 newfeature 分支中的内容。解决冲突的办法无非是二选一或者亲自合并到一起。

在解决了所有文件的冲突后，运行 ``git add`` 将它们标记为已解决。在运行一次 ``git status`` 来确认所有冲突都已解决。如果确认了所有冲突都已解决，就可以使用 ``git commit`` 来完成这次合并提交。


# 衍合（rebase）

熟练掌握 ``git rebase`` 操作，包括 ``git rebase -i`` 和 ``git rebase --onto``，掌握一种 git 工作流  

待整理   

...

# 撤销

三种状态：已修改、已暂存、已提交

## 修改最后一次提交

有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤销刚才的操作提交，可以使用 ``--amend`` 选项重新提交：

```
git commit --amend
```

此命令将使用当前的暂存区域快照提交，如果刚才提交完没有做任何改动（``git add``），直接运行此命令的话，相当于有机会重新编辑提交说明，而所提交的文件快照和之前的一样。

## 对于已修改的文件撤销

```
git checkout --[file name]
```

## 对于已暂存的文件撤销

将已暂存的撤销到修改状态，使用命令：

```
git reset HEAD [file name]
```

## 对于已提交的文件撤销

1.撤销某次提交之后的所有提交并放到修改状态区

```
git reset [commit id]
```

2.撤销某次提交之后的所有提交

```
git reset --hard [commit id]
```

3.撤销某次提交（并不删除提交历史）

```
git revert [commit id]
```

# 标签

Git 使用的标签有两种类型：

- 轻量级的标签
- 含附注的标签

轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，点子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard（GPG）来签署或验证。一般我们都建议使用含附注的标签，已保留相关信息；当然，如果只是临时性夹住标签，或者不需要旁注额外信息，用轻量级标签也没问题。

## 新建标签

1.新建含附注的标签

```
git tag -a [tagname] -m '[tag 备注]'
```

2.新建轻量级标签

```
git tag [tagname]
```

3.将标签提交到远程服务器

默认情况下，``git push`` 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行:

```
git push origin [tagname]
```

如果一次要提交所有本地标签，可使用：

```
git push --tags
```

## 查询已有标签

```
git tag
```

## 删除标签

删除本地标签：

```
git tag -d [tagname]
```

删除远程标签：

```
git push origin :refs/tags/[tagname]
```

## 检出标签

```
git checkout tags/[tagname]
```

# 小技巧

## 跳过使用暂存区域

尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做有些麻烦。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 ``git commit`` 加上 ``-a`` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来以并提交，从而跳过 ``git add`` 步骤：

```
git commit -a -m '修改了文件'
```

## 新建分支并切换到新分支
比如，我们要创建一个新分支 newfeature 并立即切换到 newfeature 分支，我们可以：

```
git checkout -b newfeature

```

## 跟踪分支

如果想要远程分支名和本地分支名一样的名字，可以用 ``--track`` 来简化

```
git fetch
git checkout --track origin/newfeature
```

如果要为本地分支设定不同于远程分支的名字，只需：   

```  
git fetch
git checkout -b new origin/newfeature
```