<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>第 6 章 块与大中枢派发</title>
    <meta name="description" content="块与大中枢派发" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="http://localhost:4000//di-6-zhang-kuai-yu-da-zhong-shu-pai-fa" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="Yiming's Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="第 6 章 块与大中枢派发" />
    <meta property="og:description" content="块与大中枢派发" />
    <meta property="og:url" content="http://localhost:4000//di-6-zhang-kuai-yu-da-zhong-shu-pai-fa" />
    <meta property="og:image" content="/assets/images/cover11.jpeg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="第 6 章 块与大中枢派发" />
    <meta name="twitter:description" content="块与大中枢派发" />
    <meta name="twitter:url" content="http://localhost:4000//di-6-zhang-kuai-yu-da-zhong-shu-pai-fa" />
    <meta name="twitter:image:src" content="/assets/images/cover11.jpeg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Yiming's Blog",
    "name": "第 6 章 块与大中枢派发",
    "url": "http://localhost:4000//di-6-zhang-kuai-yu-da-zhong-shu-pai-fa",
    "image": "/assets/images/cover11.jpeg",
    "description": "块与大中枢派发"
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Yiming's Blog" href="/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/about">About</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/assets/images/cover11.jpeg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/"><img src="/assets/images/ghost.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-speeches">

        <header class="post-header">
            <h1 class="post-title">第 6 章 块与大中枢派发</h1>
            <section class="post-meta">
            <!-- <a href='/'></a> -->

            
                
            
                
            
                
            
                
            
                
            
                
                    <a href='/author/yiming'>Yiming</a>
                
            
            <time class="post-date" datetime="2016-06-10">10 Jun 2016</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/tag/iOS'>iOS</a>
                    
                
                
            </section>
        </header>
<p></p>
        <section class="post-content">

            <p>0.如果块所捕获的变量是对象类型，那么就会自动保留它。系统在释放这个块的时候，也会将其一并释放。</p>

<p>1.如果将块定义在 Objective-C 类的实例方法中，那么除了可以访问类的所有实例变量之外，还可以使用 <code class="highlighter-rouge">self</code> 变量。块总能修改实例变量。所以在声明时无须加 <code class="highlighter-rouge">__block</code>。不过，如果通过读取或写入操作捕获了实例变量，那么也会自动把 <code class="highlighter-rouge">self</code> 变量一并捕获了，因为实例变量是与 <code class="highlighter-rouge">self</code> 所只带的实例关联在一起的。</p>

<p>2.在 block 中 直接访问实例变量和通过 <code class="highlighter-rouge">self</code> 来访问是等效的。</p>

<p>3.一定要记住：<code class="highlighter-rouge">self</code> 也是个对象，因而快在捕获它时也会将其保留。如果 <code class="highlighter-rouge">self</code> 所指点的那个对象同时也保留了块，那么这种情况通常就会导致“保留环”。</p>

<p>4.除了 “栈块” 和 “堆块”之外，还有一类块叫做 “全局块”（global block）。这种块不会捕捉任何状态（比如外围的变量等），运行时也无须有状态来参与。块所使用的整个内存区域，在编译期已经完全确定了，因此，全局块可以生命在全局内存里，而不需要在每次用到的时候于栈中创建。另外，全局块的拷贝操作是个空操作，因为全局块决不可能为系统所回收。这种块实际上相当于单例。</p>

<p>下面两种方式都是全局块（global block）：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void (^myFirstBlock)() = ^{
    NSLog(@"123");
};

void (^mySecondBlock)(int a,int b) = ^(int a,int b){
    NSLog(@"a + b = %@",@(a + b));
};
</code></pre></div></div>

<p>5.以 <code class="highlighter-rouge">typedef</code> 重新定义块类型，可令块变量用起来更加简单。</p>

<p>6.不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应 <code class="highlighter-rouge">typedef</code> 中的块签名即可，无须改动其他 <code class="highlighter-rouge">typedef</code>。</p>

<p>7.与使用委托模式的代码相比，用块写出来的代码更为整洁。委托模式有个缺点：如果类要分别使用多个获取器下载不同数据，那么就得在 <code class="highlighter-rouge">delegate</code> 回调方法里根据传入的获取器参数来切换。</p>

<p>8.建议使用同一个块来处理成功与失败情况，苹果公司似乎也是这样设计 API 的。</p>

<p>9.如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。一定要找个适当的时机解除保留环，而不能把责任推给 API 的调用者。</p>

<p>10.在 Objective-C 中，如果有多个线程要执行同一份代码，那么有时可能会出现问题。这种情况下，通常要使用锁来实现某种同步机制。在 GCD 出现之前，有两种办法:</p>

<ul>
  <li>内置的 <code class="highlighter-rouge">@synchronize</code></li>
  <li>使用 <code class="highlighter-rouge">NSLock</code> 对象</li>
</ul>

<p>11.滥用 <code class="highlighter-rouge">@synchronized(self)</code> 则会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。若是在 <code class="highlighter-rouge">self</code> 对象上频繁枷锁，那么程序可能要等另一段于此无关的代码执行完毕，才能继续执行当前代码，这样做其实并没有必要。在极端情况下，<code class="highlighter-rouge">@synchronize</code> 块会导致死锁，另外，其效率也不见得很高。</p>

<p>12.派发队列可用来表述同步寓意，这样做法要比使用 <code class="highlighter-rouge">@synchronized</code> 块或 <code class="highlighter-rouge">NSLock</code> 对象更简单。</p>

<p>13.有种简单高效的办法可以代替同步块或锁对象，那就是使用“串行同步队列”。</p>

<p>14.如果将串行同步队列改为串行异步队列，貌似看起来效率更高些，但这么改动有个坏处：如果你测一下程序性能，那么可能会发现这种写法比原来慢，因为执行异步派发时，需要拷贝块。若拷贝块所用的时间明显超过执行块所花的实现，则这种做法将比原来更慢。</p>

<p>15.多个获取方法可以并发执行，而获取方法与设置方法之间不能并发执行，利用这个特点，还能写出更快一些的代码块。利用<code class="highlighter-rouge">dispatch_brarrier_async</code>，我们可以使用并行队列。并发队列如果发现接下来要处理的块是个栅栏块。待栅栏块执行过后，再按正常方式继续向下处理。</p>

<p>16.多用 GCD，少用 <code class="highlighter-rouge">performSelector</code>。</p>

<p>17.使用 <code class="highlighter-rouge">performSelector</code>,编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC 采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p>

<p>18.延后执行可以用 <code class="highlighter-rouge">dispatch_after</code> 来实现。</p>

<p>19.GCD VS NSOperation</p>

<p>GCD 的优点：</p>

<ul>
  <li>GCD 提供的 <code class="highlighter-rouge">dispatch_after</code> 支持调度下一个操作的开始时间而不是直接进入睡眠。</li>
  <li><code class="highlighter-rouge">NSOperation</code> 中没有类似<code class="highlighter-rouge">dispatch_source_t</code>, <code class="highlighter-rouge">dispatch_io,dispatch_data_t</code>, <code class="highlighter-rouge">dispatch_semaphore_t</code> 等操作。</li>
</ul>

<p><code class="highlighter-rouge">NSOperation</code> 的优点：</p>

<ul>
  <li>GCD 没有操作依赖。我们可以让一个 Operation 依赖于另一个 Operation，这样的话尽管两个 Operation 处于同一个并行队列中，但前者会直到后者执行完毕后再执行；
GCD 没有操作优先级（GCD 有队列优先级），能够使同一个并行队列中的任务区分先后地执行，而在 GCD 中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；</li>
  <li>GCD 没有 KVO。<code class="highlighter-rouge">NSOperation</code> 可以监听一个 Operation 是否完成或取消，这样能比 GCD 更加有效地掌控我们执行的后台任务</li>
  <li>在 <code class="highlighter-rouge">NSOperationQueue</code> 中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而 GCD 没法停止已经加入 queue 的 block (其实是有的，但需要许多复杂的代码)</li>
  <li>我们能够对 <code class="highlighter-rouge">NSOperation</code> 进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将 block 任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li>
</ul>

<p>20.使用 Dispatch Group,并行执行 A、B 任务，最后执行 C 任务：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dispatch_queue_t concurrentQueue = dispatch_queue_create("me.iYiming.concurrentQueue", DISPATCH_QUEUE_CONCURRENT);

dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, concurrentQueue, ^{
   // A 任务
});

dispatch_group_async(group, concurrentQueue, ^{
   // B 任务
});

dispatch_group_notify(group, concurrentQueue, ^{
   // C 任务
});
</code></pre></div></div>

<p>21.使用 <code class="highlighter-rouge">dispatch_once</code> 创建单例：</p>

<p>单例：<strong>保证只分配一次内存</strong></p>

<ul>
  <li>调用 <code class="highlighter-rouge">alloc</code> 方法的时候，内部会调用 <code class="highlighter-rouge">allocWithZone</code> 方法，所以控制好 <code class="highlighter-rouge">allocWithZone</code> 方法的内存开辟操作就能控制 <code class="highlighter-rouge">alloc</code></li>
  <li>
    <p><code class="highlighter-rouge">copy</code>、<code class="highlighter-rouge">mutableCopy</code> 同样要控制，直接返回调用者就好（因为 <code class="highlighter-rouge">copy</code> 和 <code class="highlighter-rouge">mutableCopy</code> 是对象方法，所以如果第一次内存分配控制好了，这里直接返回 <code class="highlighter-rouge">self</code>）</p>
  </li>
  <li>MRC 下 <code class="highlighter-rouge">retain</code>、<code class="highlighter-rouge">release</code>、<code class="highlighter-rouge">retainCount</code> 处理</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //保存单例对象的静态全局变量
  static id _instance;
  + (instancetype)sharedTools {
      return [[self alloc]init];
  }
  //在调用alloc方法之后，最终会调用allocWithZone方法
  + (instancetype)allocWithZone:(struct _NSZone *)zone {
      //保证分配内存的代码只执行一次
      static dispatch_once_t onceToken;
      dispatch_once(&amp;onceToken, ^{
          _instance = [super allocWithZone:zone];
      });
      return _instance;
  }
  //这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行
  - (id)copyWithZone:(NSZone *)zone {
      return self;
  }
  //这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行
  - (id)mutableCopyWithZone:(NSZone *)zone {
      return self;
  }
  #if __has_feature(objc_arc)
  //如果是ARC环境
  #else
  //如果不是ARC环境

  //既然是单例对象，总不能被人给销毁了吧，一旦销毁了，分配内存的代码已经执行过了，就再也不能创建对象了。所以覆盖掉release操作
  - (oneway void)release {
  }
  //这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行
  - (instancetype)retain {
      return self;
  }
  //为了便于识别，这里返回 MAXFLOAT ，别的程序员看到这个数据，就能意识到这是单例。
  - (NSUInteger)retainCount {
      return MAXFLOAT;
  }
  #endif
</code></pre></div></div>

<p>22.<code class="highlighter-rouge">dispatch_sync</code> 执行 block 所在的 Queue 如果和当前 Queue 是同一个 Queue，那么会造成死锁。比如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)viewDidLoad {
  [super viewDidLoad];
  
  dispatch_sync(dispatch_get_main_queue(),^{
    NSLog(@"Hello !");
  });
  
  NSLog(@"结束");
}
</code></pre></div></div>

<p>为什么？因为 <code class="highlighter-rouge">dispatch_sync</code> 是同步的，又在 <code class="highlighter-rouge">viewDidLoad</code> 里，所以主线程等待它执行完才能打印“结束“，然而 <code class="highlighter-rouge">dispatch_sync</code> 块需要在 <code class="highlighter-rouge">dispatch_get_main_queue()</code> 主线程里添加 block <code class="highlighter-rouge">^{
    NSLog(@"Hello !");
  })</code>,因为主线程现在在等待中，所以 Block 永远无法添加进主线程队列中去，互相等待，从而造成死锁。</p>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
            
                
            
                
            
                
            
                
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/author/yiming" style="background-image: url(/assets/images/yiming.jpeg)"><span class="hidden">yiming's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/author/yiming">Yiming</a></h4>

                        
                            <p> 程序猿，90后，生于齐鲁，奋斗在京</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Beijing, China</span>
                            <span class="author-link icon-link"><a href="http://iYiming.me"> iYiming.me</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=第 6 章 块与大中枢派发&amp;url=http://localhost:4000di-6-zhang-kuai-yu-da-zhong-shu-pai-fa"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000di-6-zhang-kuai-yu-da-zhong-shu-pai-fa"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=http://localhost:4000di-6-zhang-kuai-yu-da-zhong-shu-pai-fa"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>

<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/assets/images/cover11.jpeg)" href="/di-7-zhang-xi-tong-kuang-jia">
            <section class="post">
                <h2>第 7 章 系统框架</h2>
                <p>Core Foundation 与 Foundation 的那些事</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/assets/images/cover11.jpeg)" href="/di-5-zhang-nei-cun-guan-li">
            <section class="post">
                <h2>第 5 章 内存管理</h2>
                <p>内存管理</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">Yiming's Blog</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
