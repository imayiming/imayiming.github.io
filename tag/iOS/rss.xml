<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>jekyller.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>Stay hungry, stay foolish.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>A Swift Tour</title>
	  <link>//A-Swift-Tour</link>
	  <author></author>
	  <pubDate>2018-10-24T08:13:54+08:00</pubDate>
	  <guid>//A-Swift-Tour</guid>
	  <description><![CDATA[
	     <p>1.打印 Hello, world!</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Hello, world!")
</code></pre></div></div>

<ul>
  <li>不需要引入第三方的库</li>
  <li>不需要一个 <code class="highlighter-rouge">main</code> 函数</li>
  <li>不需要在结尾处写分号</li>
</ul>

<h2 id="简单值">简单值</h2>

<p>1.使用 <code class="highlighter-rouge">let</code> 声明常量。</p>

<p>2.使用 <code class="highlighter-rouge">var</code> 声明变量。</p>

<p>3.通常不需要明确指定常量、变量类型，可以让编译器推测它的类型。</p>

<p>4.如果初始值不能够提供足够的信息（或者没有初始化值），使用 <code class="highlighter-rouge">: 类型</code> 的方式来指定类型。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let implicitDouble = 70.0
let explicitDouble: Double = 70
</code></pre></div></div>

<p>5.值不能隐式的将一个类型转化为另一种类型。如果想转化为另一种类型，应明确设置。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let label = “The width is ”
let width = 94
let widthLabel = label + String(width)
</code></pre></div></div>

<p>6.有一种简单的方式将数字转换为字符串：写在一个括号里，在括号前加一个反斜杠。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples."
let fuitSummary = "I have \(apples + oranges) pieces of fruit."
</code></pre></div></div>

<p>7.使用三个双引号来承载多行字符串。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let quotation = """
Even though there's whitespace to the left,
the actual lines aren't indented.
Except for this line.
Double quotes (") can appear without being escaped.

I still have \(apples + oranges) pieces of fruit.
"""
</code></pre></div></div>

<p>8.创建数组和字典使用方括号 <code class="highlighter-rouge">[]</code> ，在 <code class="highlighter-rouge">[]</code> 中使用索引或键访问元素。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var shoppingList = ["catfish", “water”, “tulips”]
shoppingList[1] = “bottle of water”

var occupations = [
  “Malcolm”: “Captain”,
  “Kaylee”: “Mechanic”,
]
occupations[“Jayne”] = “Public Relations”
</code></pre></div></div>

<p>9.当添加元素时数组会自动扩充。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shoppingList.append(“blue paint”)
print(shoppingList)
</code></pre></div></div>

<p>10.创建一个空数组或字典，使用初始化语法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let emptyArray = [String]()
let emptyDictionary = [String: Float]()
</code></pre></div></div>

<h2 id="控制流">控制流</h2>

<p>1.使用 <code class="highlighter-rouge">if</code> 和 <code class="highlighter-rouge">switch</code> 来做判断。</p>

<p>2.使用 <code class="highlighter-rouge">for-in</code>, <code class="highlighter-rouge">while</code>, 和 <code class="highlighter-rouge">repeat-while</code> 来循环。</p>

<p>3.围绕条件判断、循环变量的圆括号是可以省略的。</p>

<p>4.可选值绑定。如果可选值是 <code class="highlighter-rouge">nil</code>，则条件是 <code class="highlighter-rouge">false</code>；如果可选值是存在的，则将这个值付给 <code class="highlighter-rouge">let</code> 后的变量，添加为 <code class="highlighter-rouge">true</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var optionalName: String? = “John Appleseed”
var greeting = “Hello!”
if let name = optionalName {
    greeting = “Hello, \(name)”
}
</code></pre></div></div>

<p>5.另一种方式处理可选类型是通过使用 <code class="highlighter-rouge">??</code> 操作符来提供默认值。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let nickName: String? = nil
let fulName: String = “John Appleseed”
let informalGreeting = “Hi \(nickName ?? fullName)”
</code></pre></div></div>

<p>6.<code class="highlighter-rouge">switch case</code> 支持各种类型的数据和各种比较操作——不限于整形和相等的比较</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let vegetable = “red pepper”
switch vegetable {
case “celery”:
    print(“Add some raisins and make ants on a log.”)
case “cucumber”, “watercress”:
    print(“That would make a good tea sandwich.”)
case let x where x.hasSuffix(“pepper”):
    print(“Is it a spicy \(x)?”)
default:
    print(“Everything tastes good in soup.”)
}
</code></pre></div></div>

<p>7.当 <code class="highlighter-rouge">switch case</code> 符合要求，程序将会从该 <code class="highlighter-rouge">case</code> 退出，执行不会继续到下一个 <code class="highlighter-rouge">case</code>。因此没必要明确在每一个 <code class="highlighter-rouge">case</code> 后面写 <code class="highlighter-rouge">break</code>。</p>

<p>8.通过提供一对名字来用于每个 key-value 对， 用于 for-in 迭代 Dictionary 中的的项。字典是无序的集合，因此他们的键值在迭代时是任意的。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let interertingNumbers = [
    “Prime”: [2, 3, 5, 7, 11, 13],
    “Fibonacci”: [1, 1, 2, 3, 5, 8], 
     “Square”: [1, 4, 9, 16, 25]
]
var largest = 0
for (kind, numbers) in interestingNumbers {
    for number in numbers {
        if number &gt; largest {
            largest = number
        }
    }
}
print(largest)
</code></pre></div></div>

<p>9.使用 <code class="highlighter-rouge">while</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var n = 2
while n &lt; 100 {
    n *= 2
}
// Prints “128”
</code></pre></div></div>

<p>10.使用 <code class="highlighter-rouge">repeat-while</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var m = 2
repeat {
    m *= 2
} while m &lt; 100
print(m)
// Prints “128”
</code></pre></div></div>

<p>11.使用 <code class="highlighter-rouge">..&lt;</code> 创建一个忽略了最大值的范围，使用 <code class="highlighter-rouge">…</code> 创建了一个包含所有值的范围。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var total = 0
for i in 0..&lt;4 {
    total += i
}
print(total)
// Prints “6”
</code></pre></div></div>

<h2 id="函数和闭包">函数和闭包</h2>

<p>1.使用 <code class="highlighter-rouge">func</code> 来定义函数。</p>

<p>2.<code class="highlighter-rouge">funcName(parameterName)</code> 来调用函数。</p>

<p>3.使用 <code class="highlighter-rouge">-&gt;</code> 来分割参数和返回类型。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func greet(person: String, day: String) -&gt; String {
    return “Hello \(person), today is \(day).”
}
greet(person: “Bob”, day: “Tuesday”)
</code></pre></div></div>

<p>4.在默认情况下，函数使用参数名来作为参数的标签。</p>

<p>5.自定义参数标签写在参数名前面。</p>

<p>6.如果没有参数标签，使用 <code class="highlighter-rouge">_</code> 代替。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func greet(_ person: String, on day: String) -&gt; String {
    return “Hello \(person), today is \(day).”
}
greet(“John”, on: “Wednesday”)
</code></pre></div></div>

<p>7.函数可以使用元组作为返回值，用于返回多个值。</p>

<p>8.函数可以嵌套在函数中。嵌套的函数可以访问嵌套外的变量。可以使用嵌套函数来组织长或者复杂的函数代码。</p>

<p>9.函数是一等类型。这意味着函数可以作为另一个函数的返回值</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func makIncrementer() -&gt;((Int) -&gt; Int) {
    func addOne(number: Int) -&gt; Int {
         return 1 + number
    }

    return addOne
}
var increment = makeIncrementer()
increment(7)
</code></pre></div></div>

<p>10.函数可以用来作为另一个函数的参数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool {
   for item in list {
         if condition(item) {
             return true
         }
    }
    return false
}
func lessThanTen(number: Int) -&gt; Bool {
    return number &lt; 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
</code></pre></div></div>

<p>11.函数事实上是一种特殊的闭包——后续会被调用的一块代码。</p>

<p>12.使用 <code class="highlighter-rouge">{}</code> 创建一个没有名字的闭包。使用 <code class="highlighter-rouge">in</code> 来分割参数、返回值和函数主体。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>numbers.map({ (number: Int) -&gt; Int in
    let result = 3 * number
    return result
})
</code></pre></div></div>

<p>13.单行声明闭包 隐式返回 仅有声明的值。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let mappedNumbers = numbers.map({ number in 3 * number })
</code></pre></div></div>

<p>14.还可以使用数字来代替参数名字。</p>

<p>15.如果函数的最后一个参数是闭包，它可以写在 <code class="highlighter-rouge">()</code> 外面。当闭包是函数的唯一一个参数，<code class="highlighter-rouge">()</code> 可以忽略。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let sortedNumber = number.sorted { $0 &gt; $1 }
print(sortedNumbers)
</code></pre></div></div>

<h2 id="对象和类">对象和类</h2>

<p>1.用 <code class="highlighter-rouge">class ClassName</code> 的方法来创建类。</p>

<p>2.类中常量、变量的声明和往常一样。同样的，方法和函数的声明也和往常一样。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Shape {
    var numberOfSides = 0
    func simpleDescription() -&gt; String {
         return “A shape with \(numberOfSides) sides.”
    }
}
</code></pre></div></div>

<p>3.创建类的实例。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var shape = Shape()
</code></pre></div></div>

<p>4.使用点语法来访问实例的属性和方法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></pre></div></div>

<p>5.上面版本的 <code class="highlighter-rouge">Shape</code> 类没有初始化器——当实例创建时用于装配类。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class NamedShape {
    var numberOfSides: Int = 0
    var name: String

     init(name: String) {
         self.name = name
     }

     func simpleDescription() -&gt; String {
          return “A shape with \(numberOfSides) sides.”
     }
}
</code></pre></div></div>

<p>6.初始化器参数传递和函数类似。</p>

<p>7.每一个属性都需要初始化——无论是在声明时，还是在初始化器里。</p>

<p>8.想在对象被释放前做一些清理操作，使用 <code class="highlighter-rouge">deinit</code> 来创建析构器。</p>

<p>9.子类继承父类使用 <code class="highlighter-rouge">:</code>。</p>

<p>10.子类的方法可以重载父类的实现，需要使用 <code class="highlighter-rouge">override</code> 标识。父类中有此方法，子类如果没有 <code class="highlighter-rouge">override</code> 使用此方法，编译器将会报错。如果父类没有此方法，子类还使用 <code class="highlighter-rouge">override</code> ，编译器也会报错。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Square: NameShape {
    var sideLength: Double

    init(sideLength: Double, name: String) {
         self.sideLength = sideLength
         super.init(name: name)
         numberOfSides = 4
    }

    func area() -&gt; Double {
        return sideLength * sideLength
    }

    override func simpleDescription() -&gt; String {
        return “A square with sides of length \(sideLength).” 
    } 
}
let test = Square(sideLength: 5.2, name: “my test square”)
test.area()
test.simpleDescription()
</code></pre></div></div>

<p>11.除了简单的用于存储的属性，属性还可以有 <code class="highlighter-rouge">getter</code> 和 <code class="highlighter-rouge">setter</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
     }

     var perimeter: Double {
         get {
             return 3.0 * sideLength
          }
          set {
              sideLength = newValue / 3.0 
          }
     }

    override func simpleDescription() -&gt; String {
         return “An equilateral triangle with sides of length \(sideLength).”
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: “a triangle”)
print(triangle.perimeter)
// Prints “9.3”
triangle.perimeter = 9.9
print(triangle.sideLength)
// Prints “3.3000000000000003”
</code></pre></div></div>

<p>12.在 <code class="highlighter-rouge">perimeter</code> 的 <code class="highlighter-rouge">setter</code> 中，新的值有一个隐式的名字 <code class="highlighter-rouge">newValue</code>。你可以在 <code class="highlighter-rouge">set</code> 后加上 <code class="highlighter-rouge">()</code>，并在 <code class="highlighter-rouge">()</code> 里明确的提供一个名字。</p>

<p>13.注意到 <code class="highlighter-rouge">EquilateralTriangle</code> 类的初始化器有 3 个不同的步骤：
（1）设置子类定义属性的值
（2）调用父类的初始化器
（3）修改父类定义的属性值。任何额外的设置工作——使用方法、getters、setter，也在这个时机操作</p>

<p>14.使用 <code class="highlighter-rouge">willSet</code> 和 <code class="highlighter-rouge">didSet</code>。</p>

<p>15.当操作可选值时，如果在 <code class="highlighter-rouge">?</code> 前的值是 <code class="highlighter-rouge">nil</code>，任何在 <code class="highlighter-rouge">?</code> 后的操作将会被忽略，整个表达式的值为 <code class="highlighter-rouge">nil</code>。否则，可选值被解开，<code class="highlighter-rouge">?</code> 后的操作作用于打开的值。在所有情况下，整个表达式的值是一个可选类型的值。</p>

<h2 id="枚举和结构体">枚举和结构体</h2>

<p>1.使用 <code class="highlighter-rouge">enum</code> 来创建枚举。</p>

<p>2.枚举中可以包含方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum Rank: Int {
    case ace = 1
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king
    
    func simpleDescription() -&gt; String {
        switch self {
            case .ace:
                return "ace"
            case .jack:
                return "jack"
            case .queen:
                return "queen"
            case .king:
                return "king"
            default:
                return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
</code></pre></div></div>

<p>3.By default, Swift assigns the raw values starting at zero and incrementing by one each time, but you can change this behavior by explicitly specifying values. In the example above, Ace is explicitly given a raw value of 1, and the rest of the raw values are assigned in order. You can also use strings or floating-point numbers as the raw type of an enumeration. Use the rawValue property to access the raw value of an enumeration case.</p>

<p>4.Use the <code class="highlighter-rouge">init?(rawValue:)</code> initializer to make an instance of an enumeration from a raw value. It returns either the enumeration case matching the raw value or nil if there is no matching Rank.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if let convertedRank = Rank(rawValue: 3) {
    let threeDescription = convertedRank.simpleDescription()
}
</code></pre></div></div>

<p>5.The case values of an enumeration are actual values, not just another way of writing their raw values. In fact, in cases where there isn’t a meaningful raw value, you don’t have to provide one.</p>

<p>6.代码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum ServerResponse {
    case result(String, String)
    case failure(String)
}

let success = ServerResponse.result("6:00 am", "8:09 pm")
let failure = ServerResponse.failure("Out of cheese.")

switch success {
    case let .result(sunrise, sunset):
        print("Sunrise is at \(sunrise) and sunset is at \(sunset).")
    case let .failure(message):
        print("Failure...  \(message)")
}
// Prints "Sunrise is at 6:00 am and sunset is at 8:09 pm."
</code></pre></div></div>

<p>7.使用 <code class="highlighter-rouge">struct</code> 来创建结构体。结构体像类一样支持很多特性，包括方法和初始化器。类和结构体最大的不同是，结构体在传递时经常会被拷贝出一个副本，但类在传递时使用引用。</p>

<h2 id="协议和扩展">协议和扩展</h2>

<p>1.使用 <code class="highlighter-rouge">protocol</code> 声明一个协议</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
</code></pre></div></div>

<p>2.类、枚举和结构体都可以适配协议</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class SimpleClass: ExampleProtocol {
    var simpleDescription: String = "A very simple class."
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "  Now 100% adjusted."
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription

struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = "A simple structure"
    mutating func adjust() {
        simpleDescription += " (adjusted)"
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
</code></pre></div></div>

<p>3.Notice the use of the <code class="highlighter-rouge">mutating</code> keyword in the declaration of SimpleStructure to mark a method that modifies the structure. The declaration of SimpleClass doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.</p>

<p>4.Use extension to add functionality to an existing type, such as new methods and computed properties. You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension Int: ExampleProtocol {
    var simpleDescription: String {
        return "The number \(self)"
    }
    mutating func adjust() {
        self += 42
    }
}
print(7.simpleDescription)	// Prints "The number 7"
</code></pre></div></div>

<p>5.You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol. When you work with values whose type is a protocol type, methods outside the protocol definition are not available.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let protocolValue: ExampleProtocol = a
print(protocolValue.simpleDescription)
// Prints "A very simple class.  Now 100% adjusted."
// print(protocolValue.anotherProperty)  // Uncomment to see the error
</code></pre></div></div>

<p>6.Even though the variable <code class="highlighter-rouge">protocolValue</code> has a runtime type of <code class="highlighter-rouge">SimpleClass</code>, the compiler treats it as the given type of <code class="highlighter-rouge">ExampleProtocol</code>. This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.</p>

<h2 id="错误处理">错误处理</h2>

<p>1.You represent errors using any type that adopts the <code class="highlighter-rouge">Error</code> protocol.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum PrinterError: Error {
    case outOfPaper
    case noToner
    case onFire
}
</code></pre></div></div>

<p>2.Use throw to throw an error and throws to mark a function that can throw an error. If you throw an error in a function, the function returns immediately and the code that called the function handles the error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func send(job: Int, toPrinter printerName: String) throws -&gt; String {
    if printerName == "Never Has Toner" {
        throw PrinterError.noToner
    }
    return "Job sent"
 }
</code></pre></div></div>

<p>3.There are several ways to handle errors. One way is to use do-catch. Inside the doblock, you mark code that can throw an error by writing try in front of it. Inside the catch block, the error is automatically given the name error unless you give it a different name.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> do {
    let printerResponse = try send(job: 1040, toPrinter: "Bi Sheng")
    print(printerResponse)
    } catch {
        print(error)
    }
    // Prints "Job sent"
</code></pre></div></div>

<p>4.You can provide multiple catch blocks that handle specific errors. You write a pattern after catch just as you do after case in a switch.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do {
    let printerResponse = try send(job: 1440, toPrinter: "Gutenberg")
    print(printerResponse)
} catch PrinterError.onFire {
    print("I'll just put this over here, with the rest of the fire.")
} catch let printerError as PrinterError {
    print("Printer error: \(printerError).")
} catch {
    print(error)
}
// Prints "Job sent"
</code></pre></div></div>

<p>5.Another way to handle errors is to use <code class="highlighter-rouge">try?</code> to convert the result to an optional. If the function throws an error, the specific error is discarded and the result is nil. Otherwise, the result is an optional containing the value that the function returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let printerSuccess = try? send(job: 1884, toPrinter: "Mergenthaler")
let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner")
</code></pre></div></div>

<p>6.Use <code class="highlighter-rouge">defer</code> to write a block of code that is executed after all other code in the function, just before the function returns. The code is executed regardless of whether the function throws an error. You can use defer to write setup and cleanup code next to each other, even though they need to be executed at different times.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var fridgeIsOpen = false
let fridgeContent = ["milk", "eggs", "leftovers"]

func fridgeContains(_ food: String) -&gt; Bool {
    fridgeIsOpen = true
    defer {
        fridgeIsOpen = false
    }
    
    let result = fridgeContent.contains(food)
    return result
}

fridgeContains("banana")
print(fridgeIsOpen)
// Prints "false"
</code></pre></div></div>

<h2 id="泛型">泛型</h2>

<p>1.Write a name inside angle brackets to make a generic function or type.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func makeArray&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] {
    var result = [Item]()
    for _ in 0..&lt;numberOfTimes {
        result.append(item)
    }
	return result
  }
makeArray(repeating: "knock", numberOfTimes: 4)
</code></pre></div></div>

<p>2.You can make generic forms of functions and methods, as well as classes, enumerations, and structures.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Reimplement the Swift standard library's optional type
enum OptionalValue&lt;Wrapped&gt; {
    case none
    case some(Wrapped)
}
var possibleInteger: OptionalValue&lt;Int&gt; = .none
possibleInteger = .some(100)
</code></pre></div></div>

<p>3.Use where right before the body to specify a list of requirements—for example, to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool
    where T.Element: Equatable, T.Element == U.Element
{
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
     }
     return false
}
anyCommonElements([1, 2, 3], [3])
</code></pre></div></div>

<p>4.Writing <code class="highlighter-rouge">&lt;T: Equatable&gt;</code> is the same as writing <code class="highlighter-rouge">&lt;T&gt; ... where T: Equatable</code>.</p>

	  ]]></description>
	</item>

	<item>
	  <title>fastlane 使用总结</title>
	  <link>//fastlane</link>
	  <author></author>
	  <pubDate>2017-03-04T20:56:09+08:00</pubDate>
	  <guid>//fastlane</guid>
	  <description><![CDATA[
	     <p><img src="https://github.com/fastlane/fastlane/raw/master/fastlane/assets/fastlane_text.png" alt="" /></p>

<p>fastlane 真是相见恨晚。其实在好久前就 star 过 <a href="https://github.com/fastlane/fastlane">这个项目</a>，但 star 就是 star，star 完就该干嘛就干嘛去了，像朋友推荐了一本书，买来从未翻过。</p>

<p>好，废话少说，进入正题，fastlane 是个什么东东呢？</p>

<blockquote>
  <p>fastlane is a tool for iOS, Mac, and Android developers to automate tedious tasks like generating screenshots, dealing with provisioning profiles, and releasing your application.</p>
</blockquote>

<p>自动帮我们构建 App，然后发布 App。拿 iOS 应用来说，就是打包 App，发布 App 到 App Store。对，没错，自动帮我们提交 App 到 App Store。想想原先发布 App 都纯手工打造，浪费人力物力，现在点一个按钮就可以搞定，爽不爽？就在前些天继 fabric 后，fastlane 也被 Google 收购啦！</p>

<!--- more -->

<h2 id="安装">安装</h2>

<p>fastlane 是 ruby 脚本，确定 ruby 版本，要高于 2.0 版本：</p>

<pre><code class="language-SHELL">$ ruby -v
</code></pre>

<p>首先需要安装最新版本的 Xcode 命令行工具：</p>

<pre><code class="language-Shell">$ xcode-select --install
</code></pre>

<p>安装 fastlane:</p>

<pre><code class="language-Shell">$ sudo gem install -n /usr/local/bin fastlane
</code></pre>

<p>查看 fastlane 版本：</p>

<pre><code class="language-Shell">$ fastlane --version
</code></pre>

<h2 id="为项目配置-fastlane">为项目配置 fastlane</h2>

<pre><code class="language-Shell">$ cd 项目
$ fastlane init
</code></pre>

<p><code class="highlighter-rouge">fastlane init</code> 会询问你的 Apple ID （itunes connect 登录邮箱）及 itunes connect 密码。帮你生成 fastlane 文件夹，包含文件如下:</p>

<pre><code class="language-Shell">.
├── Appfile
├── Deliverfile
├── Fastfile
├── metadata
│   ├── app_icon.png
│   ├── copyright.txt
│   ├── en-US
│   │   ├── description.txt
│   │   ├── keywords.txt
│   │   ├── marketing_url.txt
│   │   ├── name.txt
│   │   ├── privacy_url.txt
│   │   ├── release_notes.txt
│   │   └── support_url.txt
│   ├── primary_category.txt
│   ├── primary_first_sub_category.txt
│   ├── primary_second_sub_category.txt
│   ├── secondary_category.txt
│   ├── secondary_first_sub_category.txt
│   ├── secondary_second_sub_category.txt
│   └── zh-Hans
│       ├── description.txt
│       ├── keywords.txt
│       ├── marketing_url.txt
│       ├── name.txt
│       ├── privacy_url.txt
│       ├── release_notes.txt
│       └── support_url.txt
└── screenshots
    └── README.txt

</code></pre>

<h4 id="appfile-文件">Appfile 文件</h4>

<p>包含：</p>

<ul>
  <li>App Bundle ID</li>
  <li>Itunes Connect 邮箱</li>
  <li>Team ID</li>
</ul>

<pre><code class="language-Ruby">app_identifier "com.test.test" # The bundle identifier of your app
apple_id "test@test.com" # Your Apple email address

team_id "T8E8S8T88"  # Developer Portal Team ID
</code></pre>

<h4 id="deliverfile">Deliverfile</h4>

<p>配置 Itunes Connect 中应用信息，比如 App 关键字、隐私 URL、App 介绍、版本更新介绍等。</p>

<p><strong>metadata 文件夹里 和 Deliverfile 都可以配置 Itunes Connect 的数据，但后者优先级高。</strong></p>

<p>也就是说，metadata 文件夹中 txt 文件的内容都可以写在 Deliverfile 里，而不用出现在 metadata 文件夹中。</p>

<p>Deliverfile 格式如下：</p>

<pre><code class="language-Ruby"># App Bundle ID
app_identifier com.test.test 

# Itunes Connect 邮箱
username test@test.com 

# 应用名称

name({
'zh-Hans' =&gt; '测试应用-很牛X的应用'
})

# 应用描述

description({
'zh-Hans' =&gt; '这是一个测试应用'
})

# 关键词

keywords({
  "zh-Hans" =&gt; "关键词1, 关键词2"
})
 
# 技术支持网址

surpport_url({
'zh-Hans' =&gt; 'http://www.surpporturl.com'
}) 

# 营销网址
marketing_url({
'zh-Hans' =&gt; 'http://www.marketingurl.com'
})

# 隐私政策网址
privacy_url({
'zh-Hans' =&gt; 'http://www.privacyurl.com'
})

# 版本描述

release_notes({
'zh-Hans' =&gt; '这次只是修复 bug 没有新功能'
})

# 版权
copyright "#{Time.now.year} Test Inc."

# 审核信息（审核所用的登录名 密码）
app_review_information(
  first_name: "Felix",
  last_name: "Krause",
  phone_number: "+43 123123123",
  email_address: "github@krausefx.com",
  demo_user: "demoUser",
  demo_password: "demoPass",
  notes: "such notes, very text"
)

# 是否自动发布
automatic_release true
</code></pre>

<p>除了上面列出的，还有:</p>

<p>1.应用分级</p>

<pre><code class="language-Ruby">app_rating_config_path "../rating_config.json"
</code></pre>

<blockquote>
  <p>You can set the app age ratings using deliver. You’ll have to create and store a JSON configuration file. Copy the <a href="https://github.com/fastlane/fastlane/blob/master/deliver/assets/example_rating_config.json">template</a> to your project folder and pass the path to the JSON file using the app_rating_config_path option.</p>
</blockquote>

<blockquote>
  <p>The keys/values on the top allow values from 0-2, and the items on the bottom allow only 0 or 1. More information in the <a href="https://github.com/fastlane/fastlane/blob/master/deliver/Reference.md">Reference.md</a>.</p>
</blockquote>

<p>2.应用分类 如 社交类下面的工具类</p>

<p>请参考 <a href="https://github.com/fastlane/fastlane/blob/master/deliver/Reference.md">https://github.com/fastlane/fastlane/blob/master/deliver/Reference.md</a></p>

<p>3.提交的信息</p>

<p>什么是提交信息？当你提交 App 的时候，会出现下图，这就是我们说的提交信息：</p>

<p><img src="/images/fastlane/01.jpeg" alt="01" /></p>

<p>这个设置请参考：</p>

<p><a href="https://github.com/fastlane/fastlane/blob/master/spaceship/lib/spaceship/tunes/app_submission.rb#L18-L69">https://github.com/fastlane/fastlane/blob/master/spaceship/lib/spaceship/tunes/app_submission.rb#L18-L69</a></p>

<p>我的设置是这样的：</p>

<pre><code class="language-Ruby">submission_information: ({
          export_compliance_encryption_updated: false,
          add_id_info_uses_idfa: true,
          add_id_info_serves_ads: false,
          add_id_info_tracks_install: true,
          add_id_info_tracks_action: true,
          add_id_info_limits_tracking: true
        })
</code></pre>

<p>更多内容请参考： <a href="https://github.com/fastlane/fastlane/blob/master/deliver/Deliverfile.md">https://github.com/fastlane/fastlane/blob/master/deliver/Deliverfile.md</a></p>

<h4 id="fastfile">Fastfile</h4>

<p>fastfile 用来配置管理 lane。</p>

<p>格式如下：</p>

<pre><code class="language-Ruby">fastlane_version "2.19.1"

default_platform :ios

platform :ios do
  before_all do
    # 开始 
  end

  desc "发布 App 到 App Store"
  lane :release do
    cert
    sigh
    produce
    gym
    deliver
  end

  # You can define as many lanes as you want

  after_all do |lane|
    # 结束
  end

  error do |lane, exception|
    # 错误
  end
end
</code></pre>

<p>我们可以在 开始、结束、失败时执行一些脚本，用于配置、发消息提示开发者执行状态。</p>

<p>比如执行一段 shell：</p>

<pre><code class="language-Shell">sh ./msg.sh
</code></pre>

<p><strong>重点介绍下 lane 的用法及内部命令。</strong></p>

<pre><code class="language-Ruby">desc "发布 App 到 App Store"
lane :release do
  produce
  cert
  sigh 
  pem
  snapshot
  frameit
  increment_build_number
  gym
  deliver
end
</code></pre>

<ul>
  <li><code class="highlighter-rouge">desc</code> 用于介绍这个 lane是做什么用的</li>
  <li><code class="highlighter-rouge">lane :</code> 后面的 <code class="highlighter-rouge">release</code> 是这个 lane 的名字 执行这个 lane 时，可以直接使用 <code class="highlighter-rouge">fastlane release</code></li>
</ul>

<p>注：</p>

<p><code class="highlighter-rouge">increment_build_number</code> 时如果出现错误:</p>

<blockquote>
  <p>There does not seem to be a CURRENT_PROJECT_VERSION key set for this project. Add this key to your target’s expert build settings.</p>
</blockquote>

<p>请参阅：<a href="https://developer.apple.com/library/content/qa/qa1827/_index.html">https://developer.apple.com/library/content/qa/qa1827/_index.html</a></p>

<p>重点介绍下里面的命令：</p>

<p>1.produce</p>

<blockquote>
  <p>Create new iOS apps on iTunes Connect and Dev Portal using the command line</p>
</blockquote>

<p>在 iTunes Connect 里创建 App</p>

<p>2.cert</p>

<blockquote>
  <p>Automatically create and maintain iOS code signing certificates</p>
</blockquote>

<p>使用证书创建私钥及签名</p>

<p>3.sign</p>

<blockquote>
  <p>Because you would rather spend your time building stuff than fighting provisioning</p>
</blockquote>

<p>创建、更新、下载和修复 provisioning profiles,支持 App Store, Ad Hoc, Development 和企业 profiles</p>

<p>4.pem</p>

<blockquote>
  <p>Automatically generate and renew your push notification profiles</p>
</blockquote>

<p>自动生成推送的 profiles 及 pem 文件</p>

<p>5.snapshot</p>

<blockquote>
  <p>Automate taking localized screenshots of your iOS and tvOS apps on every device</p>
</blockquote>

<p>创建设备截图</p>

<p>6.frameit</p>

<blockquote>
  <p>Quickly put your screenshots into the right device frames</p>
</blockquote>

<p>给截图加上边框</p>

<p>7.gym</p>

<blockquote>
  <p>Building your iOS apps has never been easier</p>
</blockquote>

<p>生成 ipa 文件</p>

<p>8.deliver</p>

<blockquote>
  <p>Upload screenshots, metadata, and your app to the App Store</p>
</blockquote>

<p>将截图、介绍信息、ipa 发送到 App Store</p>

<h2 id="lane">lane</h2>

<ul>
  <li>创建 App</li>
  <li>更新 App</li>
  <li>Testflight 管理 Testflight 用户及上传至 Testflight</li>
</ul>

<h2 id="其他">其他</h2>

<h4 id="简聊">简聊</h4>

<pre><code class="language-Shell">msgTitle=$1
msgContent=$2
msgImageURL=$3
msgURL=$4

curl -d authorName=XXX -d title=${msgTitle} -d text=${msgContent} -d imageUrl=${msgImageURL} -d redirectUrl=${msgURL} https://jianliao.com/v2/services/webhook/xxx
</code></pre>

<p>在 lane 执行前可以执行消息提示：</p>

<pre><code class="language-Ruby">platform :ios do
  before_all do
    sh "./jianliao.sh '标题：开始构建' '内容：我开始构建我的项目' 'http://iyiming.me/favicon.jpg' 'redirectUrl'" 
  end
</code></pre>

<p>完成、失败时类似。</p>

<h4 id="蒲公英">蒲公英</h4>

<p>打包成功后可以发送至 蒲公英:</p>

<pre><code class="language-Shell">curl -F "file=@XXX.ipa" -F "uKey=XXXX" -F "_api_key=XXX" -F "installType=2" -F "password=XXX" http://www.pgyer.com/apiv1/app/upload
</code></pre>

	  ]]></description>
	</item>

	<item>
	  <title>第 7 章 系统框架</title>
	  <link>//di-7-zhang-xi-tong-kuang-jia</link>
	  <author></author>
	  <pubDate>2016-06-11T11:34:05+08:00</pubDate>
	  <guid>//di-7-zhang-xi-tong-kuang-jia</guid>
	  <description><![CDATA[
	     <p>0.CoreFoundation 与 Foundation 不仅名字相似，而且还有更为紧密的联系。Foundation 框架中的许多功能，都可以在此框架中找到对应的 C 语言 API。有个功能佳作“无缝桥接”（tollfree bridging），可以把 CoreFoundation 中的 C 语言数据结构平滑转换为 Foundation 中的 Objective-C 对象，也可以反向旋转。</p>

<p>1.ARC 下只考虑 Objective-C 对象的内存，对于非 Objective-C 对象，比如 CoreFoundation 中的需要自己考虑内存管理问题。</p>

<p>2.Objective-C 编程的一项重要特点，那就是：经常需要使用底层的 C 语言级 API。用  C 语言来实现 API 的好处是，可以绕过 Objective-C 的运行期系统，从而提升执行速度。</p>

<p>3.多用块枚举，少用 for 循环。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[array enumerateObjectsUsingBlock:^(NSString *  _Nonnull name, NSUInteger idx, BOOL * _Nonnull stop) {

	...
	
	if ([name isEqualToString:@"Tom"]) {
		stop = YES;
	}
}];
</code></pre></div></div>

<p>4.块枚举优点：</p>

<ul>
  <li>遍历时可以直接从块里获取更多信息。在遍历数组时，可以知道当前所针对的下标。</li>
  <li>能够修改块的方法签名，以免进行类型转换操作。从效果上讲，相当于把本来需要执行的类型转换操作交给方法签名来做。</li>
</ul>

<p>5.Core Foundation 与 Foundation 内存问题</p>

<p><code class="highlighter-rouge">__bridge</code> 什么也不做，仅仅是转换。此种情况下：</p>

<ol>
  <li>从 Cocoa 转换到 Core，需要人工 <code class="highlighter-rouge">CFRetain</code>，否则，Cocoa 指针释放后， 传出去的指针则无效。</li>
  <li>从 Core 转换到 Cocoa，需要人工 <code class="highlighter-rouge">CFRelease</code>，否则，Cocoa 指针释放后，对象引用计数仍为1，不会被销毁。</li>
</ol>

<p><code class="highlighter-rouge">__bridge_retained</code> 转换后自动调用 <code class="highlighter-rouge">CFRetain</code>，即帮助自动解决上述 1 的情形。</p>

<p><code class="highlighter-rouge">__bridge_transfer</code> 转换后自动调用 <code class="highlighter-rouge">CFRelease</code>，即帮助自动解决上述 2 的情形。</p>

<ul>
  <li><code class="highlighter-rouge">__bridge</code> 用法</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge CFStringRef)string;
</code></pre></div></div>
<p>只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当 <code class="highlighter-rouge">string</code> 对象被释放的时候，<code class="highlighter-rouge">cfstring</code> 也不能被使用了。</p>

<ul>
  <li><code class="highlighter-rouge">__bridge_retained</code> 用法</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge_retained CFStringRef)string;
...
CFRelease(cfString); // 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release
</code></pre></div></div>
<p>使用 <code class="highlighter-rouge">__bridge_retained</code> 可以通过转换目标处（ <code class="highlighter-rouge">cfString</code> ）的 <code class="highlighter-rouge">retain</code> 处理，来使所有权转移。即使 <code class="highlighter-rouge">string</code> 变量被释放，<code class="highlighter-rouge">cfString</code> 还是可以使用具体的对象。只是有一点，由于 Core Foundation 的对象不属于 ARC 的管理范畴，所以需要自己 <code class="highlighter-rouge">release</code>。</p>

<p>可以用 <code class="highlighter-rouge">CFBridgingRetain</code> 替代 <code class="highlighter-rouge">__bridge_retained</code> 关键字：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = CFBridgingRetain(string);
...
CFRelease(cfString); // 由于Core Foundation不在ARC管理范围内，所以需要主动release。
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">__bridge_transfer</code></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CFStringRef cfString = CFStringCreate...();
NSString *string = (__bridge_transfer NSString *)cfString;
 
// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release
</code></pre></div></div>

<p>所有权被转移的同时，被转换变量将失去对象的所有权。当 Core Foundation 对象类型向Objective-C 对象类型转换的时候，会经常用到 <code class="highlighter-rouge">__bridge_transfer</code> 关键字。</p>

<p>同样，我们可以使用 <code class="highlighter-rouge">CFBridgingRelease()</code> 来代替 <code class="highlighter-rouge">__bridge_transfer</code> 关键字。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CFStringRef cfString = CFStringCreate...();
NSString *string = CFBridgingRelease(cfString);
</code></pre></div></div>

<p>6.<code class="highlighter-rouge">NSCache</code> VS <code class="highlighter-rouge">NSDictionary</code></p>

<ul>
  <li><code class="highlighter-rouge">NSCache</code> 胜过 <code class="highlighter-rouge">NSDictionary</code> 之处在于，当系统资源将要耗尽时，它可以自动删减缓存。如果采用普通的字典，那么就要自己编写挂钩，在系统发出“低内存”通知时手工删减缓存。</li>
  <li><code class="highlighter-rouge">NSCache</code>还会先行删减 “最久未使用”对象。</li>
  <li><code class="highlighter-rouge">NSCache</code>并不会拷贝键，而是会保留它。</li>
  <li><code class="highlighter-rouge">NSCache 是线程安全的，而</code>NSDictionary`` 则绝对不具备此优势。</li>
</ul>

<p>7.只有那种“重新计算起来很费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘获取的数据。</p>

<p>8.<code class="highlighter-rouge">+ (void)load</code> 方法</p>

<ul>
  <li><code class="highlighter-rouge">+ (void)load</code>，对于加入运行期系统的每个类以及分类来说，必定会调用此方法，而且仅调用一次。当包含类或分类的程序库载入系统时，就会执行此方法，而这通常就是指应用程序启动的时候，若程序是为 iOS 平台设计的，则肯定会在此时执行。</li>
  <li>在 <code class="highlighter-rouge">load</code> 方法中使用其他类是不安全的。</li>
  <li><code class="highlighter-rouge">load</code> 方法并不像普通的方法那样，它并不遵从那套继承规则。分类和所属的类里，都可能出现 load 方法。此时两种实现代码都会调用，类的实现要比分类的实现先执行。</li>
  <li><code class="highlighter-rouge">load</code> 方法务必实现得精简些，也就是要尽量减少其所执行的操作，因为整个应用程序在执行 <code class="highlighter-rouge">load</code> 方法时都会阻塞。</li>
</ul>

<p>9.<code class="highlighter-rouge">+ (void)initialize</code> 方法</p>

<ul>
  <li>对于每个类来说，该方法会在程序首次用该类之前调用，且只调用一次。它是惰性调用的，只有程序用到了相关的类时，才会调用。</li>
  <li>此方法与 <code class="highlighter-rouge">+ (void)load</code>方法不同的是，运行期系统在执行该方法时，是处于正常状态的，因此，从运行期系统完整度上来讲，此时可以完全使用并调用任意类中的任意方法。</li>
  <li><code class="highlighter-rouge">+ (void) initialize</code> 方法与其他消息一样，如果某个类未实现它，而其超类实现了，那么就会运行超类实现的代码。</li>
</ul>

<p>10.<code class="highlighter-rouge">NSTimer</code> 会保留其目标对象。如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#import "YMTimerCircularReferenceViewController.h"
</span>
<span class="k">@interface</span> <span class="nc">YMTimerCircularReferenceViewController</span> <span class="p">()</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSTimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">YMTimerCircularReferenceViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
    
    <span class="n">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nf">timerWithTimeInterval</span><span class="p">:</span><span class="mi">1</span> <span class="nf">target</span><span class="p">:</span><span class="n">self</span> <span class="n">selector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">timerSelector</span><span class="p">)</span> <span class="n">userInfo</span><span class="o">:</span><span class="nb">nil</span> <span class="n">repeats</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
    <span class="p">[[</span><span class="n">NSRunLoop</span> <span class="nf">currentRunLoop</span><span class="p">]</span> <span class="nf">addTimer</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">timer</span> <span class="nf">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">timerSelector</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,[</span><span class="n">NSDate</span> <span class="nf">date</span><span class="p">]);</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"YMTimerCircularReferenceViewController dealloc"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当 <code class="highlighter-rouge">YMTimerCircularReferenceViewController</code> pop 时，上面的 <code class="highlighter-rouge">dealloc</code>方法不被调用。</p>

<p>解决办法，加一个 NSTimer 类别：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#import "NSTimer+YMBlock.h"
</span>
<span class="k">@implementation</span> <span class="nc">NSTimer</span> <span class="p">(</span><span class="nl">YMBlock</span><span class="p">)</span>

<span class="k">+</span> <span class="p">(</span><span class="n">NSTimer</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)</span><span class="nf">ym_timerWithTimeInterval</span><span class="p">:(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">ti</span> <span class="nf">block</span><span class="p">:(</span><span class="n">nullable</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">block</span> <span class="nf">userInfo</span><span class="p">:(</span><span class="n">nullable</span> <span class="n">id</span><span class="p">)</span><span class="nv">userInfo</span> <span class="nf">repeats</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">yesOrNo</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nf">timerWithTimeInterval</span><span class="p">:</span><span class="n">ti</span> <span class="nf">target</span><span class="p">:</span><span class="n">self</span> <span class="n">selector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">ym_blockInvoke</span><span class="o">:</span><span class="p">)</span> <span class="n">userInfo</span><span class="o">:</span><span class="p">[</span><span class="n">block</span> <span class="nf">copy</span><span class="p">]</span> <span class="n">repeats</span><span class="o">:</span><span class="n">yesOrNo</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">ym_blockInvoke</span><span class="p">:(</span><span class="n">NSTimer</span> <span class="o">*</span><span class="p">)</span><span class="nv">timer</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)()</span> <span class="o">=</span> <span class="n">timer</span><span class="p">.</span><span class="n">userInfo</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">block</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div></div>

<p>注：此处虽然依然有保留换，<code class="highlighter-rouge">self</code> 引用 <code class="highlighter-rouge">self</code>，因为是类对象，无须回收。</p>


	  ]]></description>
	</item>

	<item>
	  <title>第 6 章 块与大中枢派发</title>
	  <link>//di-6-zhang-kuai-yu-da-zhong-shu-pai-fa</link>
	  <author></author>
	  <pubDate>2016-06-10T11:32:44+08:00</pubDate>
	  <guid>//di-6-zhang-kuai-yu-da-zhong-shu-pai-fa</guid>
	  <description><![CDATA[
	     <p>0.如果块所捕获的变量是对象类型，那么就会自动保留它。系统在释放这个块的时候，也会将其一并释放。</p>

<p>1.如果将块定义在 Objective-C 类的实例方法中，那么除了可以访问类的所有实例变量之外，还可以使用 <code class="highlighter-rouge">self</code> 变量。块总能修改实例变量。所以在声明时无须加 <code class="highlighter-rouge">__block</code>。不过，如果通过读取或写入操作捕获了实例变量，那么也会自动把 <code class="highlighter-rouge">self</code> 变量一并捕获了，因为实例变量是与 <code class="highlighter-rouge">self</code> 所只带的实例关联在一起的。</p>

<p>2.在 block 中 直接访问实例变量和通过 <code class="highlighter-rouge">self</code> 来访问是等效的。</p>

<p>3.一定要记住：<code class="highlighter-rouge">self</code> 也是个对象，因而快在捕获它时也会将其保留。如果 <code class="highlighter-rouge">self</code> 所指点的那个对象同时也保留了块，那么这种情况通常就会导致“保留环”。</p>

<p>4.除了 “栈块” 和 “堆块”之外，还有一类块叫做 “全局块”（global block）。这种块不会捕捉任何状态（比如外围的变量等），运行时也无须有状态来参与。块所使用的整个内存区域，在编译期已经完全确定了，因此，全局块可以生命在全局内存里，而不需要在每次用到的时候于栈中创建。另外，全局块的拷贝操作是个空操作，因为全局块决不可能为系统所回收。这种块实际上相当于单例。</p>

<p>下面两种方式都是全局块（global block）：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void (^myFirstBlock)() = ^{
    NSLog(@"123");
};

void (^mySecondBlock)(int a,int b) = ^(int a,int b){
    NSLog(@"a + b = %@",@(a + b));
};
</code></pre></div></div>

<p>5.以 <code class="highlighter-rouge">typedef</code> 重新定义块类型，可令块变量用起来更加简单。</p>

<p>6.不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应 <code class="highlighter-rouge">typedef</code> 中的块签名即可，无须改动其他 <code class="highlighter-rouge">typedef</code>。</p>

<p>7.与使用委托模式的代码相比，用块写出来的代码更为整洁。委托模式有个缺点：如果类要分别使用多个获取器下载不同数据，那么就得在 <code class="highlighter-rouge">delegate</code> 回调方法里根据传入的获取器参数来切换。</p>

<p>8.建议使用同一个块来处理成功与失败情况，苹果公司似乎也是这样设计 API 的。</p>

<p>9.如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。一定要找个适当的时机解除保留环，而不能把责任推给 API 的调用者。</p>

<p>10.在 Objective-C 中，如果有多个线程要执行同一份代码，那么有时可能会出现问题。这种情况下，通常要使用锁来实现某种同步机制。在 GCD 出现之前，有两种办法:</p>

<ul>
  <li>内置的 <code class="highlighter-rouge">@synchronize</code></li>
  <li>使用 <code class="highlighter-rouge">NSLock</code> 对象</li>
</ul>

<p>11.滥用 <code class="highlighter-rouge">@synchronized(self)</code> 则会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。若是在 <code class="highlighter-rouge">self</code> 对象上频繁枷锁，那么程序可能要等另一段于此无关的代码执行完毕，才能继续执行当前代码，这样做其实并没有必要。在极端情况下，<code class="highlighter-rouge">@synchronize</code> 块会导致死锁，另外，其效率也不见得很高。</p>

<p>12.派发队列可用来表述同步寓意，这样做法要比使用 <code class="highlighter-rouge">@synchronized</code> 块或 <code class="highlighter-rouge">NSLock</code> 对象更简单。</p>

<p>13.有种简单高效的办法可以代替同步块或锁对象，那就是使用“串行同步队列”。</p>

<p>14.如果将串行同步队列改为串行异步队列，貌似看起来效率更高些，但这么改动有个坏处：如果你测一下程序性能，那么可能会发现这种写法比原来慢，因为执行异步派发时，需要拷贝块。若拷贝块所用的时间明显超过执行块所花的实现，则这种做法将比原来更慢。</p>

<p>15.多个获取方法可以并发执行，而获取方法与设置方法之间不能并发执行，利用这个特点，还能写出更快一些的代码块。利用<code class="highlighter-rouge">dispatch_brarrier_async</code>，我们可以使用并行队列。并发队列如果发现接下来要处理的块是个栅栏块。待栅栏块执行过后，再按正常方式继续向下处理。</p>

<p>16.多用 GCD，少用 <code class="highlighter-rouge">performSelector</code>。</p>

<p>17.使用 <code class="highlighter-rouge">performSelector</code>,编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC 采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p>

<p>18.延后执行可以用 <code class="highlighter-rouge">dispatch_after</code> 来实现。</p>

<p>19.GCD VS NSOperation</p>

<p>GCD 的优点：</p>

<ul>
  <li>GCD 提供的 <code class="highlighter-rouge">dispatch_after</code> 支持调度下一个操作的开始时间而不是直接进入睡眠。</li>
  <li><code class="highlighter-rouge">NSOperation</code> 中没有类似<code class="highlighter-rouge">dispatch_source_t</code>, <code class="highlighter-rouge">dispatch_io,dispatch_data_t</code>, <code class="highlighter-rouge">dispatch_semaphore_t</code> 等操作。</li>
</ul>

<p><code class="highlighter-rouge">NSOperation</code> 的优点：</p>

<ul>
  <li>GCD 没有操作依赖。我们可以让一个 Operation 依赖于另一个 Operation，这样的话尽管两个 Operation 处于同一个并行队列中，但前者会直到后者执行完毕后再执行；
GCD 没有操作优先级（GCD 有队列优先级），能够使同一个并行队列中的任务区分先后地执行，而在 GCD 中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；</li>
  <li>GCD 没有 KVO。<code class="highlighter-rouge">NSOperation</code> 可以监听一个 Operation 是否完成或取消，这样能比 GCD 更加有效地掌控我们执行的后台任务</li>
  <li>在 <code class="highlighter-rouge">NSOperationQueue</code> 中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而 GCD 没法停止已经加入 queue 的 block (其实是有的，但需要许多复杂的代码)</li>
  <li>我们能够对 <code class="highlighter-rouge">NSOperation</code> 进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将 block 任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li>
</ul>

<p>20.使用 Dispatch Group,并行执行 A、B 任务，最后执行 C 任务：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dispatch_queue_t concurrentQueue = dispatch_queue_create("me.iYiming.concurrentQueue", DISPATCH_QUEUE_CONCURRENT);

dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, concurrentQueue, ^{
   // A 任务
});

dispatch_group_async(group, concurrentQueue, ^{
   // B 任务
});

dispatch_group_notify(group, concurrentQueue, ^{
   // C 任务
});
</code></pre></div></div>

<p>21.使用 <code class="highlighter-rouge">dispatch_once</code> 创建单例：</p>

<p>单例：<strong>保证只分配一次内存</strong></p>

<ul>
  <li>调用 <code class="highlighter-rouge">alloc</code> 方法的时候，内部会调用 <code class="highlighter-rouge">allocWithZone</code> 方法，所以控制好 <code class="highlighter-rouge">allocWithZone</code> 方法的内存开辟操作就能控制 <code class="highlighter-rouge">alloc</code></li>
  <li>
    <p><code class="highlighter-rouge">copy</code>、<code class="highlighter-rouge">mutableCopy</code> 同样要控制，直接返回调用者就好（因为 <code class="highlighter-rouge">copy</code> 和 <code class="highlighter-rouge">mutableCopy</code> 是对象方法，所以如果第一次内存分配控制好了，这里直接返回 <code class="highlighter-rouge">self</code>）</p>
  </li>
  <li>MRC 下 <code class="highlighter-rouge">retain</code>、<code class="highlighter-rouge">release</code>、<code class="highlighter-rouge">retainCount</code> 处理</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //保存单例对象的静态全局变量
  static id _instance;
  + (instancetype)sharedTools {
      return [[self alloc]init];
  }
  //在调用alloc方法之后，最终会调用allocWithZone方法
  + (instancetype)allocWithZone:(struct _NSZone *)zone {
      //保证分配内存的代码只执行一次
      static dispatch_once_t onceToken;
      dispatch_once(&amp;onceToken, ^{
          _instance = [super allocWithZone:zone];
      });
      return _instance;
  }
  //这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行
  - (id)copyWithZone:(NSZone *)zone {
      return self;
  }
  //这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行
  - (id)mutableCopyWithZone:(NSZone *)zone {
      return self;
  }
  #if __has_feature(objc_arc)
  //如果是ARC环境
  #else
  //如果不是ARC环境

  //既然是单例对象，总不能被人给销毁了吧，一旦销毁了，分配内存的代码已经执行过了，就再也不能创建对象了。所以覆盖掉release操作
  - (oneway void)release {
  }
  //这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行
  - (instancetype)retain {
      return self;
  }
  //为了便于识别，这里返回 MAXFLOAT ，别的程序员看到这个数据，就能意识到这是单例。
  - (NSUInteger)retainCount {
      return MAXFLOAT;
  }
  #endif
</code></pre></div></div>

<p>22.<code class="highlighter-rouge">dispatch_sync</code> 执行 block 所在的 Queue 如果和当前 Queue 是同一个 Queue，那么会造成死锁。比如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)viewDidLoad {
  [super viewDidLoad];
  
  dispatch_sync(dispatch_get_main_queue(),^{
    NSLog(@"Hello !");
  });
  
  NSLog(@"结束");
}
</code></pre></div></div>

<p>为什么？因为 <code class="highlighter-rouge">dispatch_sync</code> 是同步的，又在 <code class="highlighter-rouge">viewDidLoad</code> 里，所以主线程等待它执行完才能打印“结束“，然而 <code class="highlighter-rouge">dispatch_sync</code> 块需要在 <code class="highlighter-rouge">dispatch_get_main_queue()</code> 主线程里添加 block <code class="highlighter-rouge">^{
    NSLog(@"Hello !");
  })</code>,因为主线程现在在等待中，所以 Block 永远无法添加进主线程队列中去，互相等待，从而造成死锁。</p>

	  ]]></description>
	</item>

	<item>
	  <title>第 5 章 内存管理</title>
	  <link>//di-5-zhang-nei-cun-guan-li</link>
	  <author></author>
	  <pubDate>2016-06-09T11:29:20+08:00</pubDate>
	  <guid>//di-5-zhang-nei-cun-guan-li</guid>
	  <description><![CDATA[
	     <p>下图列出了一些 ARC 下的内存问题，就各个问题一一描述下：</p>

<p><img src="/images/effective_objectivec_2.0/2.png" alt="2.jpg" /></p>

<h2 id="循环引用">循环引用</h2>

<h4 id="普通的两个变量互相引用">普通的两个变量互相引用</h4>

<p>上代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>self.object1 = [[YMNormalCircularReferenceObject alloc] init];
self.object2 = [[YMNormalCircularReferenceObject alloc] init];

self.object1.data = self.object2;
self.object2.data = self.object1;
</code></pre></div></div>

<p>两个对象互相引用，解决办法一个使用 <code class="highlighter-rouge">weak</code> 标识属性。</p>

<h4 id="block-循环引用">Block 循环引用</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#import "YMBlockCircularReferenceViewController.h"
</span>
<span class="k">typedef</span> <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">YMDownloaderCompleteBlock</span><span class="p">)(</span><span class="n">id</span> <span class="n">data</span><span class="p">);</span>

<span class="k">@interface</span> <span class="nc">YMDownloader</span> <span class="p">()</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">YMDownloaderCompleteBlock</span> <span class="n">downloaderCompleteBlock</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">YMDownloader</span>


<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">downloadDataWithURL</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span> <span class="nf">completeBlock</span><span class="p">:(</span><span class="n">YMDownloaderCompleteBlock</span><span class="p">)</span><span class="nv">block</span> <span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">downloaderCompleteBlock</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
    
    <span class="p">[</span><span class="n">self</span> <span class="nf">downloadDataWithURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">downloadDataWithURL</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span> <span class="p">{</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">downloaderCompleteBlock</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">@end</span>


<span class="k">@interface</span> <span class="nc">YMBlockCircularReferenceViewController</span> <span class="p">()</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">YMDownloader</span> <span class="o">*</span><span class="n">downloader</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">id</span> <span class="n">data</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">YMBlockCircularReferenceViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
    
    <span class="n">self</span><span class="p">.</span><span class="n">downloader</span> <span class="o">=</span> <span class="p">[[</span><span class="n">YMDownloader</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">downloader</span> <span class="nf">downloadDataWithURL</span><span class="p">:[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="s">@""</span><span class="p">]</span> <span class="nf">completeBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"YMBlockCircularReferenceViewController dealloc 方法"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">self</code> 保留了 <code class="highlighter-rouge">downloader</code> ，<code class="highlighter-rouge">downloader</code> 拷贝了块，块里保留了 <code class="highlighter-rouge">self</code>,解决办法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)downloadDataWithURL:(NSURL *)url {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        sleep(2);
        
        self.downloaderCompleteBlock(url);
        self.downloaderCompleteBlock = nil;
    });
}
</code></pre></div></div>

<h4 id="nstimer">NSTimer</h4>

<p><code class="highlighter-rouge">NSTimer</code> 会保留其目标对象</p>

<p>继续上代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#import "YMTimerCircularReferenceViewController.h"
</span>
<span class="k">@interface</span> <span class="nc">YMTimerCircularReferenceViewController</span> <span class="p">()</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSTimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">YMTimerCircularReferenceViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
    
    <span class="n">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nf">timerWithTimeInterval</span><span class="p">:</span><span class="mi">1</span> <span class="nf">target</span><span class="p">:</span><span class="n">self</span> <span class="n">selector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">timerSelector</span><span class="p">)</span> <span class="n">userInfo</span><span class="o">:</span><span class="nb">nil</span> <span class="n">repeats</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
    <span class="p">[[</span><span class="n">NSRunLoop</span> <span class="nf">currentRunLoop</span><span class="p">]</span> <span class="nf">addTimer</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">timer</span> <span class="nf">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">timerSelector</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,[</span><span class="n">NSDate</span> <span class="nf">date</span><span class="p">]);</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"YMTimerCircularReferenceViewController dealloc"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当 <code class="highlighter-rouge">YMTimerCircularReferenceViewController</code> pop 时，上面的 <code class="highlighter-rouge">dealloc</code>方法不被调用。</p>

<p>解决办法，加一个 <code class="highlighter-rouge">NSTimer</code> 类别：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#import "NSTimer+YMBlock.h"
</span>
<span class="k">@implementation</span> <span class="nc">NSTimer</span> <span class="p">(</span><span class="nl">YMBlock</span><span class="p">)</span>

<span class="k">+</span> <span class="p">(</span><span class="n">NSTimer</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)</span><span class="nf">ym_timerWithTimeInterval</span><span class="p">:(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">ti</span> <span class="nf">block</span><span class="p">:(</span><span class="n">nullable</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">block</span> <span class="nf">userInfo</span><span class="p">:(</span><span class="n">nullable</span> <span class="n">id</span><span class="p">)</span><span class="nv">userInfo</span> <span class="nf">repeats</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">yesOrNo</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nf">timerWithTimeInterval</span><span class="p">:</span><span class="n">ti</span> <span class="nf">target</span><span class="p">:</span><span class="n">self</span> <span class="n">selector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">ym_blockInvoke</span><span class="o">:</span><span class="p">)</span> <span class="n">userInfo</span><span class="o">:</span><span class="p">[</span><span class="n">block</span> <span class="nf">copy</span><span class="p">]</span> <span class="n">repeats</span><span class="o">:</span><span class="n">yesOrNo</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">ym_blockInvoke</span><span class="p">:(</span><span class="n">NSTimer</span> <span class="o">*</span><span class="p">)</span><span class="nv">timer</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)()</span> <span class="o">=</span> <span class="n">timer</span><span class="p">.</span><span class="n">userInfo</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">block</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div></div>

<p>注：此处虽然依然有保留换，<code class="highlighter-rouge">self</code> 引用 <code class="highlighter-rouge">self</code>，因为是类对象，无须回收。<code class="highlighter-rouge">CADisplayLink</code> 类似。</p>

<h4 id="悬挂指针">悬挂指针</h4>

<p>在 Scheme 中开启即可，如下图：</p>

<p><img src="/images/effective_objectivec_2.0/3.png" alt="3.jpg" /></p>

<h2 id="持有释放不匹配">持有、释放不匹配</h2>

<h4 id="performselector">performselector</h4>

<p>使用 <code class="highlighter-rouge">performSelector</code>,编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC 采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p>

<h4 id="corefoundation---foundation">CoreFoundation - Foundation</h4>

<p>上代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (IBAction)coreFoundationToFoundation:(id)sender {
   CFStringRef coreFoundationStr = CFStringCreateWithCString(NULL, "Hello World!", kCFStringEncodingUnicode);
    
    NSString *foundationStr = (__bridge NSString *)(coreFoundationStr);
    // NSString *foundationStr = CFBridgingRelease(coreFoundationStr);
    
    NSLog(@"foundationStr:%@",foundationStr);
}

- (IBAction)foundationToCoreFoundation:(id)sender {
    NSString *foundationStr = [[NSString alloc] initWithFormat:@"Hello World!"];
    
    CFStringRef coreFoundationStr = CFBridgingRetain(foundationStr);
    NSLog(@"coreFoundationStr:%@",coreFoundationStr);
}

- (IBAction)noMemoryManagement:(id)sender {
    // NSString *foundationStr = @"Hello World!";
    // CFStringRef coreFoundationStr = (__bridge CFStringRef)(foundationStr);
    
    
    // CFStringRef coreFoundationStr = CFStringCreateWithCString(NULL, "Hello World!", kCFStringEncodingUnicode);
    // NSString *foundationStr = (__bridge NSString *)(coreFoundationStr);
}
</code></pre></div></div>

<p>Core Foundation 与 Foundation 内存问题</p>

<p><code class="highlighter-rouge">__bridge</code> 什么也不做，仅仅是转换。此种情况下：</p>

<ol>
  <li>从 Cocoa 转换到 Core，需要人工 <code class="highlighter-rouge">CFRetain</code>，否则，Cocoa 指针释放后， 传出去的指针则无效。</li>
  <li>从 Core 转换到 Cocoa，需要人工 <code class="highlighter-rouge">CFRelease</code>，否则，Cocoa 指针释放后，对象引用计数仍为1，不会被销毁。</li>
</ol>

<p><code class="highlighter-rouge">__bridge_retained</code> 转换后自动调用 <code class="highlighter-rouge">CFRetain</code>，即帮助自动解决上述 1 的情形。</p>

<p><code class="highlighter-rouge">__bridge_transfer</code> 转换后自动调用 <code class="highlighter-rouge">CFRelease</code>，即帮助自动解决上述 2 的情形。</p>

<ul>
  <li><code class="highlighter-rouge">__bridge</code> 用法</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge CFStringRef)string;
</code></pre></div></div>
<p>只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当 <code class="highlighter-rouge">string</code> 对象被释放的时候，<code class="highlighter-rouge">cfstring</code> 也不能被使用了。</p>

<ul>
  <li><code class="highlighter-rouge">__bridge_retained</code> 用法</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge_retained CFStringRef)string;
...
CFRelease(cfString); // 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release
</code></pre></div></div>
<p>使用 <code class="highlighter-rouge">__bridge_retained</code> 可以通过转换目标处（ <code class="highlighter-rouge">cfString</code> ）的 <code class="highlighter-rouge">retain</code> 处理，来使所有权转移。即使 <code class="highlighter-rouge">string</code> 变量被释放，<code class="highlighter-rouge">cfString</code> 还是可以使用具体的对象。只是有一点，由于 Core Foundation 的对象不属于 ARC 的管理范畴，所以需要自己 <code class="highlighter-rouge">release</code>。</p>

<p>可以用 <code class="highlighter-rouge">CFBridgingRetain</code> 替代 <code class="highlighter-rouge">__bridge_retained</code> 关键字：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = CFBridgingRetain(string);
...
CFRelease(cfString); // 由于Core Foundation不在ARC管理范围内，所以需要主动release。
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">__bridge_transfer</code></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CFStringRef cfString = CFStringCreate...();
NSString *string = (__bridge_transfer NSString *)cfString;
 
// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release
</code></pre></div></div>

<p>所有权被转移的同时，被转换变量将失去对象的所有权。当 Core Foundation 对象类型向 Objective-C 对象类型转换的时候，会经常用到 <code class="highlighter-rouge">__bridge_transfer</code> 关键字。</p>

<p>同样，我们可以使用 <code class="highlighter-rouge">CFBridgingRelease()</code> 来代替 <code class="highlighter-rouge">__bridge_transfer</code> 关键字。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CFStringRef cfString = CFStringCreate...();
NSString *string = CFBridgingRelease(cfString);
</code></pre></div></div>

<p>— 华丽分割线 —</p>

<p>其实看完上面的解释，就不用介绍上面代码出现的问题了。简要说下：</p>

<p>0.<code class="highlighter-rouge">- (IBAction)coreFoundationToFoundation:(id)sender</code> 方法创建了 CFStringRef 对象，并未使用，需要使用下面代码释放：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *foundationStr = CFBridgingRelease(coreFoundationStr);
</code></pre></div></div>

<p>1.<code class="highlighter-rouge">- (IBAction)foundationToCoreFoundation:(id)sender</code> 方法里接手并<code class="highlighter-rouge">retain</code> 了 Objective-C 对象的字符串，但是没有做到释放。</p>

<h4 id="try--catch">@try … @catch</h4>

<p>再上代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)viewDidLoad {
    [super viewDidLoad];
    
    @try {
        NSArray *array = @[@"a", @"b", @"c"];
        [array objectAtIndex:3];
    } @catch (NSException *exception) {
        // 处理异常
        NSLog(@"throw an exception: %@", exception.reason);
    } @finally {
        NSLog(@"正常执行");
    }
}
</code></pre></div></div>
<p>当执行到 <code class="highlighter-rouge">[array objectAtIndex:3];</code> 发生崩溃，这时 <code class="highlighter-rouge">array</code> 并未释放，解决办法是开启编译器标志 <code class="highlighter-rouge">-fobjc-arc-exceptions</code></p>

<h2 id="其他">其他</h2>

<h4 id="autoreleasepool-block-降低内存峰值">@autoreleasepool block 降低内存峰值</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (id object in array) {
	@@autoreleasepool {
		...
	}
}
</code></pre></div></div>

<p>合理运用自动释放池，可降低应用程序的内存峰值。</p>

<p>是否应该用 <code class="highlighter-rouge">@autoreleasepool { }</code> 来优化效率，完全取决于具体的应用程序。首先得监控内存用量，判断其中有没有需要解决的问题，如果没完成这一步，那就别急着优化。尽管<code class="highlighter-rouge">@autoreleasepool { }</code> 的开销不太大，但毕竟还是有的，所以尽量不要建立额外的自动释放池。</p>

<h4 id="需自己负责释放方法命名规则">需自己负责释放方法命名规则</h4>

<p>在一开始的图中的几个方法，需要在 MRC 下需要对象自己手动释放。</p>

	  ]]></description>
	</item>

	<item>
	  <title>第 4 章 协议与分类</title>
	  <link>//di-4-zhang-xie-yi-yu-fen-lei</link>
	  <author></author>
	  <pubDate>2016-06-08T11:27:45+08:00</pubDate>
	  <guid>//di-4-zhang-xie-yi-yu-fen-lei</guid>
	  <description><![CDATA[
	     <p>0.利用分类机制，我们无须继承子类即可直接为当前类添加方法，而在其他编程语言中，则需通过集成子类来实现。由于 Objective-C 运行期系统是高度动态的，所以才支持这一特性。</p>

<p>1.使用分类机制把类的实现代码划分成易于管理的小块</p>

<p>2.将应该视为“私有”的方法归入名叫 Private 的分类中，以隐藏实现细节。</p>

<p>3.分类中的方法是直接添加在类里面的，他们就好比这个类中的固有方法。将分类方法加入类中这一操作是在运行期系统加载分类时完成的。运行期系统会把分类中所实现的每个方法都加入类的方法列表中。如果类中本来就有此方法，而分类又实现了一次，那么分类中的方法会覆盖原来那一份实现代码。实际上可能会发生很多次覆盖，比如某个分类中的方法覆盖了“主实现”中的相关方法，而另外一个分类中的方法又覆盖了这个分类中的方法。多次覆盖的结果以最后一个分类为准。</p>

<p>4.要解决上述问题，一般的做法是：以命名空间来区别各个分类的名称与其中所定义的方法。想在 Objective-C 中实现命名空间功能，只有一个办法，就是给相关名称都加上某个公用的前缀。</p>

<p>5.除了 class-continuation 分类 之外，其他分类都无法向勒种新增实例变量，因此，他们无法把实现属性所需的实例变量合成出来。</p>

<p>6.通过类的匿名分类向类中新增实例变量，如果某属性在主接口中声明为“只读”，而类的内部又要用设置方法修改此属性，那么就在匿名分类中将其扩展为可读写</p>

<p>7.若想使类所遵循的协议不为人所知，则可以在匿名分类中声明</p>

<p>8.协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。</p>

<p>9.使用匿名对象来隐藏类型名称（或类名）。</p>

	  ]]></description>
	</item>

	<item>
	  <title>第 3 章 接口和 API 设计</title>
	  <link>//di-3-zhang-jie-kou-he-api-she-ji</link>
	  <author></author>
	  <pubDate>2016-06-07T11:25:23+08:00</pubDate>
	  <guid>//di-3-zhang-jie-kou-he-api-she-ji</guid>
	  <description><![CDATA[
	     <p>0.Objective-C 没有其他语言那种内置的命名空间（namespace）机制。鉴于此，我们在起名时要设法避免潜在的命名冲突，否则很容易就重名了。如果发生命名冲突，那么应用程序的链接过程就会出错，因为其中出现了重复符号,<code class="highlighter-rouge">duplicate symbol</code>错误。</p>

<p>1.避免此问题的唯一办法就是变相实现命名空间：为所有名称都加上适当前缀。使用 Cocoa 创建应用程序时一定要注意，Apple 宣称其保留使用所有“两字母前缀”的权利，所以自己选用的前缀应该是三个字母的。</p>

<p>2.不仅是类名，应用程序中的所有名称都应该加上前缀。如果要既有类新增 category，那么一定要给 “分类” 及分类中方法加上前缀。</p>

<p>3.在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法，若全能初始化方法与超类不同，则需复写超类中的对应方法（所谓的全能初始化方法就是，其他初始化方法都要调用它，如 <code class="highlighter-rouge">NSDate</code> 中的 <code class="highlighter-rouge">initWithTimeIntervalSinceReferenceDate:</code> 就是全能初始化方法）。</p>

<p>4.NSObject 协议中还有个方法要注意，那就是 <code class="highlighter-rouge">debugDescription</code>，此方法的用意与 <code class="highlighter-rouge">description</code> 非常相似。二者区别在于，<code class="highlighter-rouge">debugDescription</code> 方法是开发者在调试器（debugger）中以控制台命令打印对象时才调用的。在 <code class="highlighter-rouge">NSObject</code> 类的默认视线中，此方法知识直接调用了 <code class="highlighter-rouge">description</code>。</p>

<p>5.实现 <code class="highlighter-rouge">description</code> 方法返回一个有意义的字符串，用以描述该实例。若想在调试时打印出更详尽的对象描述信息，则应实现 <code class="highlighter-rouge">debugDescription</code> 方法.</p>

<p>6.默认情况下，属性是“既可读又可写的”，这样设计出来的类都是“可变的”。一般情况下我们要建模的数据未必需要改变。具体到编程实践中，则应该尽量把对外公布出来的属性设为只读，而且只在确有必要时才将属性对外公布。再将属性在对象内部重新声明为 <code class="highlighter-rouge">readwrite</code>。</p>

<p>7.给私有化方法名称添加前缀（<code class="highlighter-rouge">p_method</code>, <code class="highlighter-rouge">p</code> 表示私有）。苹果公司喜欢单用一个下划线作为私有方法的前缀。你也许也想照着苹果公司的办法指哪一个下划线作前缀，这样做可能会惹来大麻烦：如果苹果公司提供的某个类中继承了一个子类，那么你在子类里可能会无意间复写了父类的同名方法，鉴于此，苹果公司在文档中说，开发者不应该单用一个下划线做前缀。</p>

<p>8.若想令自己缩写的对象具有拷贝功能，则需要实现 <code class="highlighter-rouge">NSCoping</code> 协议</p>

<p>9.如果自订一个对象分为可变版本与不可变版本。那么就要同事实现 <code class="highlighter-rouge">NSCoping</code> 与 <code class="highlighter-rouge">NSMutableCopying</code> 协议。</p>

<p>10.在可变对象上调用 <code class="highlighter-rouge">copy</code> 方法会返回另外一个不可变类的实例。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[NSMutableArray copy] =&gt; NSArray
[NSArray mutableCopy] =&gt; NSMutableArray
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>第 2 章 对象、消息、运行时</title>
	  <link>//di-2-zhang-dui-xiang-xiao-xi-yun-xing-shi</link>
	  <author></author>
	  <pubDate>2016-06-06T19:22:07+08:00</pubDate>
	  <guid>//di-2-zhang-dui-xiang-xiao-xi-yun-xing-shi</guid>
	  <description><![CDATA[
	     <p>0.用 Objective-C 等面向对象语言编程时，“对象”就是“基本构造单元”（building block），开发者可以通过对象来存储并传递数据。在对象之间传递数据并执行任务的过程就叫做“消息传递”（Messaging）。</p>

<p>1.当应用程序运行起来以后，为其提供相关支持的代码叫做“Objective-C 运行期环境”（Objective-C Runtime），它提供了一些使得对象之间能够提供消息的重要函数，并且包含创建类实例所用的全部逻辑。在理解了运行期环境中各个部分协同工作的原理之后，你的开发水平将会进一步提升。</p>

<p>2.属性（property）是 Objective-C 的一项特性，用于封装对象中的数据。Objective-C对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”（access method）来访问。其中“获取方法”（getter）用于读取变量值，而“设置方法”（setter）用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分，开发者可以令编译器自动编写与属性相关的存取方法。此特性引入了一种新的“点语法”（dot syntax），使开发者可以更为容易地依照类对象来访问存放于其中的数据。</p>

<p>3.要访问属性，可以使用“点语法“，在纯 C 中，如果想访问分配在栈上的 struct 结构体里面的成员，也需使用类似语法。编译器会吧”点语法“转换为对存取方法的调用，使用”点语法“的效果与直接调用存取方法相同。因此，使用”点语法“和直接调用存取方法之间没有丝毫差别。</p>

<p>4.属性还有更多优势。如果使用了属性的话，那么编译器就会自动编写访问这些属性所需的方法，此过程叫做”自动合成“。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些”合成方法“的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加上下划线，以此作为实例变量的名字。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字。</p>

<p>5.一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>

<p>6.若不想令编译器自动合成存取方法，则可以自己实现。如果你只实现了其中一个存取方法，那么另外一个还是会由编译器来合成。还有一种办法能阻止编译器自动合成存取方法，就是使用 <code class="highlighter-rouge">@dynamic</code> 关键字,它会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。而且，在编译访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。</p>

<p>7.使用属性时还有一个问题要注意，就是其各种特质（attribute）设定也会影响编译器所生成的存取方法。属性可以拥有的特质分为 4 类：</p>

<ul>
  <li>原子性</li>
  <li>读/写权限</li>
  <li>内存管理语义</li>
  <li>方法名</li>
</ul>

<p>8.在属性不添加任何特质时，MRC 默认情况是 <code class="highlighter-rouge">atomic</code>，<code class="highlighter-rouge">assign</code>，<code class="highlighter-rouge">readwrite</code>。ARC 默认情况是 <code class="highlighter-rouge">atomic</code>，<code class="highlighter-rouge">strong</code>，<code class="highlighter-rouge">readwrite</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@property</span> <span class="n">BOOL</span> <span class="n">checked</span><span class="p">;</span>
</code></pre></div></div>

<p><a href="http://stackoverflow.com/questions/5802511/what-are-the-defaults-values-for-property-in-ios">http://stackoverflow.com/questions/5802511/what-are-the-defaults-values-for-property-in-ios</a><br />
<a href="http://www.devtalking.com/articles/you-should-to-know-property/">http://www.devtalking.com/articles/you-should-to-know-property/</a></p>

<p>9.原子性：在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性（atomicity）。如果属性具备 nonatomic 特质，则不使用同步锁。</p>

<p>10.具备 readwrite（读写）特质的属性拥有“获取方法”（getter）与“设置方法”（setter）。</p>

<p>11.具备 readonly（只读）特质的属性仅拥有获取方法。你可以使用此特质把某个属性对外公开为只读属性，然后在“class-continuation 分类”中将其重新定义为读写属性。</p>

<p>12.<code class="highlighter-rouge">assign</code> 设置方法 只会执行针对 “纯量类型”（scalar type，例如 <code class="highlighter-rouge">CGFloat</code> 或 <code class="highlighter-rouge">NSInteger</code> 等）的简单赋值操作。</p>

<p>13.<code class="highlighter-rouge">strong</code> 此特质表明该属性定义了一种“拥有关系”（owning relationship）。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</p>

<p>14.<code class="highlighter-rouge">weak</code> 此特质表明该属性定义了一种“非拥有关系”（nonowning relationship）。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 <code class="highlighter-rouge">assign</code> 类似，然而在属性所指的对象遭到销毁时，属性值也会清空（nil out）。</p>

<p>15.<code class="highlighter-rouge">unsafe_unretained</code> 此特质的语义和 assign 相同，但是它适用于 对象类型，该特质表达一种 “非拥有关系”（“不保留”，unretained），当目标对象遭到销毁时，属性值不会自动清空（“不安全”，unsafe），这一点与 weak 有区别。</p>

<p>16.<code class="highlighter-rouge">copy</code> 此特质所表达的所属关系与 <code class="highlighter-rouge">strong</code> 类似。然而设置方法并不保留新值，而是将其拷贝（<code class="highlighter-rouge">copy</code>）。</p>

<p>17.当属性类型为 <code class="highlighter-rouge">NSString*</code> 时，经常用此特质来保护其封装性。因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”（immutable）的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”（mutable），就应该在设置新属性值时拷贝一份。<code class="highlighter-rouge">NSDictionary</code> 和 <code class="highlighter-rouge">NSArray</code> 也应如此。</p>

<p>18.可通过如下特质来制定存取方法的方法名：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">isOn</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">on</span><span class="p">;</span>
</code></pre></div></div>

<p>19.setter=<name> 指定“设置方法”的方法名。</name></p>

<p>20.通过上述特质，可以微调由编译器所合成的存取方法。不过需要注意：若是自己来实现这些存取方法，那么应该<strong>保证其具备相关属性所声明的特质</strong>。比方说，如果将某个属性声明为 copy，那么就应该在”设置方法“中拷贝相关对象，否则会误导该属性的使用者，而且，若是不遵从这一约定，还会令程序产生 bug。</p>

<p>21.由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明<strong>初始化方法在设置这些属性值时所用的方式</strong>。要是不写明语义的话。该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作是多余而且低效的。</p>

<p>22.<code class="highlighter-rouge">atomic</code> 与 <code class="highlighter-rouge">nonatomic</code> 的区别</p>

<p>具备 <code class="highlighter-rouge">atomic</code> 特质的获取方法会通过锁定机制来保证其原子性。这也就是说，如果两个线程读写同一属性，那么不论何时，总能看到有效的属性值。若是不加锁的话（或者说使用 nonatomic 语义），那么当其中一个线程正在改写某属性值，另一个线程也许会突然闯入，把尚未修改好的属性值读取出来。发生这种情况时，线程读到的属性值可能不对。</p>

<p>23.atomic 一定是线程安全的吗？</p>

<p>如果开发过 iOS 程序，你就会发现，其中所有属性都声明为 nonatomic。这样做的历史原因是：<strong>在 iOS 中使用同步锁的开销较大，这会带来性能问题。一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全”（thread safety），若要实现“线程安全 ”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。因此，开发 iOS 程序时一般都会使用 nonatomic 属性。</strong>但是在开发Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。</p>

<p>24.消息转发</p>

<p><a href="http://www.jianshu.com/p/1bde36ad9938">http://www.jianshu.com/p/1bde36ad9938</a></p>

<p>25.Runtime（貌似满大街都是的文章了）</p>

<p><a href="http://www.jianshu.com/p/e071206103a4">http://www.jianshu.com/p/e071206103a4</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>第 1 章 熟悉 Objective-C</title>
	  <link>//di-1-zhang-shou-xi-objective-c</link>
	  <author></author>
	  <pubDate>2016-06-05T11:08:45+08:00</pubDate>
	  <guid>//di-1-zhang-shou-xi-objective-c</guid>
	  <description><![CDATA[
	     <p>0.若是用过另一种面向对象语言（C++ 或 Java），那么就能理解 Objective-C 所用的许多范式与模板了。然而语法上也许会显得陌生，因为该语言使用“消息结构”(messaging structure)而非“函数调用”（function calling）。Objective-C 语言由 Smalltalk 演化而来，后者是消息型语言的鼻祖。</p>

<p>1.关键区别在于：<strong>使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定</strong>。</p>

<p>2.对 1 注解：如果范例代码中调用的函数是多态的，那么在运行时就要按照“虚方法表”（virtual table）来查出到底应该执行哪个函数实现。而采用消息结构的语言，不论是否多态，总是在运行时才会去查找索要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象也要在运行时处理，其过程叫做“动态绑定”（dynamic binding）。</p>

<p>3.Objective-C 的重要工作都由“运行期组件”（runtime component）而非编译器来完成。使用 Objective-C 的面向对象特性所需的全部数据结构及函数都在运行期组件里面。举例来说，运行期组件中含有全部内存管理方法。<strong>运行期组件本质上就是一种与开发者所编写代码相连接的“动态库”（dynamic library），其代码能把开发者编写的所有程序粘合起来。这样的话，只需更新运行期组件，即可提升应用程序性能。</strong>而那种许多工作都在“编译期”（compile time）完成的语言，若想获得类似的性能提升，则要重新编译应用程序代码。</p>

<p>4.初始化一个字符串：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *someString = @"The string";
</code></pre></div></div>

<p>这种语法基本上是照搬 C 语言的。它声明了一个名为 <code class="highlighter-rouge">someString</code> 的变量,其类型是 <code class="highlighter-rouge">NSString*</code>。也就是说，此变量为指向 <code class="highlighter-rouge">NSString</code> 的 指针。所有 Objective-C 语言的对象都必须这样声明，因为对象所占内存总是分配在”堆空间”（heap space）中，而绝不会分配在“栈”（stack）上。</p>

<p>5.分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。</p>

<p>6.Objective-C 将堆内存管理抽象出来了。不需要用 <code class="highlighter-rouge">malloc</code> 及 <code class="highlighter-rouge">free</code> 来分配或释放对象所占内存。Objective-C 运行期环境就把这部分工作抽象为一套内存管理架构，名叫“引用计数”。</p>

<p>7.在 Objective-C 代码中，有时会遇到定义里不含 <code class="highlighter-rouge">*</code> 的变量,它们可能会使用“栈空间”（stack space）。这些变量所保存的不是 Objective-C 对象。比如 CoreGraphic 框架中的 <code class="highlighter-rouge">CGRect</code> 是 C 结构体。整个系统框架都在用这种结构体，因为如果改用 Objective-C 对象来做的话。</p>

<p>8.Objective-C 为 C 语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。</p>

<p>9.除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用<strong>向前声明</strong>（如果提前声明 <code class="highlighter-rouge">Person</code> 类，使用：<code class="highlighter-rouge">@class Person;</code>）来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。<strong>若引入许多根本用不到的内容，会增加编译时间</strong>。</p>

<p>10.看下面这个例子(仅列出.h文件)：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//YMPerson.h
</span><span class="cp">#import &lt;Foundation/Foundation.h&gt;
#import "YMEmployer.h"
</span>
<span class="k">@interface</span> <span class="nc">YMPerson</span> <span class="p">:</span> <span class="nc">NSObject</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">firstName</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">lastName</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">YMEmployer</span> <span class="o">*</span><span class="n">employer</span><span class="p">;</span>

<span class="k">@end</span>

<span class="c1">//YMEmployer.h
</span><span class="cp">#import &lt;Foundation/Foundation.h&gt;
#import "YMPerson.h"
</span>
<span class="k">@interface</span> <span class="nc">YMEmployer</span> <span class="p">:</span> <span class="nc">NSObject</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">addEmployee</span><span class="p">:(</span><span class="n">YMPerson</span> <span class="o">*</span><span class="p">)</span> <span class="n">person</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></div></div>

<p>这样会出现问题，虽然使用 <code class="highlighter-rouge">#import</code> 而非 <code class="highlighter-rouge">#include</code> 指令虽然不会导致死循环，但这却意味着两个类有一个无法被正确编译。而使用向前声明却可以解决这个问题。</p>

<p>11.有时候必须要在头文件中引入其他头文件：</p>

<ul>
  <li>如果你写的类继承自某个超类，则必须引入定义那个超类的头文件。</li>
  <li>如果要声明你写的类遵从某个协议，那么该协议必须有完整定义，且不能使用向前声明。向前声明只能高度编译器有某个协议，而此时编译器却要知道该协议中定义的方法。</li>
</ul>

<p>12.引入协议头文件，最好把协议单独放在一个头文件中。然而有些协议，例如“委托协议”，就不用单独写一个头文件了，在这种情况下，协议只有与接收协议委托的类放在一起定义才有意义。</p>

<p>13.每次在头文件中引入其他头文件之前，都要先问问自己这样做是否确有必要。如果可以用向前声明取代引入，那么就不要引入。若因为要实现属性。实例变量或者要遵循协议而必须引入头文件，则应尽量将其一直“ class-continuation 分类”。这样不仅可以所见编译时间，而且还能降低彼此依赖程度。若是依赖关系过于复杂，则会给维护带来麻烦，而且，如果只要把代码的某个部分开放为公共API的话，太复杂的依赖关系也会出现问题。</p>

<p>14.应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。</p>

<p>15.用字面量语法创建数组时要注意，若数组元素对象中有 <code class="highlighter-rouge">nil</code>，则会抛出异常，因为字面量语法实际上指示一种语法糖（ syntactic sugar ），其效果等于是先创建了一个数组，然后把方括号内的所有对象都加到这个数组中。这样会让我们提前知道错误，而使用最原始的方法虽不会抛出异常使我们不好找到异常。</p>

<p>16.字典中的对象和键必须都是 Objective-C 对象，所以不能把整数值（如 <code class="highlighter-rouge">10</code> ）直接放进去，而是将其封装在<code class="highlighter-rouge">NSNumber</code>实例中（ <code class="highlighter-rouge">@10</code> ）才行。</p>

<p>17.使用字面量语法创建出来的字符串、数组、字典对象都是不可变的（immutable）。若想要可变版本的对象，则需复制一份：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSMutableArray *mutable = [[@1, @2, @3] mutableCopy];
</code></pre></div></div>
<p>18.字面量语法有个小小的限制，就是除了字符串意外，所差出来对象必须属于 Foundation 框架才行。</p>

<p>19.在编写代码时经常要定义常量。掌握了 Objective-C 与其 C 语言基础的人，也许会用这种方法来做：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define ANIMATION_DURATION 0.3
</code></pre></div></div>

<p>上述预处理命令会把源代码中的 <code class="highlighter-rouge">ANIMATION_DURATION</code> 字符串替换为 <code class="highlighter-rouge">0.3</code> 。这可能是你想要的效果，不过这样定义出来的常量<strong>没有类型信息</strong>。</p>

<p>20.要想解决上面的问题，应该设法利用编译器的某些特性才对。有个办法比用预处理指令来定义常量更好。比方说，下面这行代码就定义了一个类型为 <code class="highlighter-rouge">NSTimeInteval</code> 的常量：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static const NSTimeInterval kAnimationDuration = 0.3;
</code></pre></div></div>

<p>这样定义的常量包含类型信息，其好处是清楚地描述了常量的含义。由此可知该常量类型为 <code class="highlighter-rouge">NSTimeInterval</code>,这有助于为其编写开发文档。如果要定义许多变量，那么这种方式能令稍后阅读代码的人更易理解其意图。</p>

<p>21.<strong>若常量局限于某“编译单元”（也就是“实现文件“）之内，则在前面加字母 <code class="highlighter-rouge">k</code>；若常量在类之外可见，则通常以类名为前缀</strong>。</p>

<p>22.若不打算公开某个常量，则应将其定义在使用该常量的实现文件里。变量一定要同时用 <code class="highlighter-rouge">static</code> 与 <code class="highlighter-rouge">const</code> 来声明。</p>

<ul>
  <li>若视图修改由 <code class="highlighter-rouge">const</code> 修饰符所声明的变量，那么编译器就会报错。</li>
  <li><code class="highlighter-rouge">static</code> 修饰符则意味着该变量仅在定义此变量的编译单元中可见。编译器每收到一个便一单元，就会输出一份”目标文件”。在 Objective-C 的语境下，“编译单元”一词通常指每个类的实现文件（以 <code class="highlighter-rouge">.m</code> 为后缀名）。假如声明此变量时不加 <code class="highlighter-rouge">static</code>,则编译器会为它创建一个“外部符号”（external symbol）。</li>
</ul>

<p>23.有时候需要对外公开某个常量。比方说，可能要在类代码中调用NSNotificationCenter来通知他人。用一个对象来派发通知，令其他欲接收通知的对象向该对象注册，这样就能实现此功能了。派发通知时，需要使用字符串来表示此项通知的名称，而这个名字就可以声明为一个外界可见的长值变量(constant variable)。这样的话，注册者无须知道实际字符串值，只需以常值变量来注册自己想要接收的通知即可。应该这样定义：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//在 .h 文件中
extern NSString *const YMStringConstant;

//在 .m 文件中
NSString *const YMStringConstant = @"Value";
</code></pre></div></div>

<p><strong>这个常量在头文件中“声明”，且在实现文件中“定义”。注意 <code class="highlighter-rouge">const</code> 修饰符在常量类型中的位置。</strong></p>

<p>24.注意常量的名字。<strong>为避免名称冲突，最好是用与之相关的类名做前缀</strong>。系统框架中一般都这样做。例如 UIKit 就按照这种方式来声明用作通知名称的全局常量。其中有类似 <code class="highlighter-rouge">UIApplicationDidEnterBackgroundNotification</code> 与 <code class="highlighter-rouge">UIApplicationWillEnterForegroundNotification</code> 这样的常量名。</p>

<p>25.不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，<strong>编译器也不会产生警告信息</strong>，这样导致应用程序中的常量值不一致。</p>

<p>26.在实现文件中使用 <code class="highlighter-rouge">static const</code> 来定义”只在编译单元内可见的常量“。由于此类常量不在全局符号表中，所以无需为其名称加前缀。</p>

<p>27.在头文件中使用 <code class="highlighter-rouge">extern</code> 来声明全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名称做前缀。</p>

<p>28.应该用枚举来表示状态机的状态、传递给方法的选项以及状态吗等值，给这些值起个易懂的名字。</p>

<p>29.如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用。那么就讲各选项值定义为 <code class="highlighter-rouge">2</code> 的幂，以便通过按位或操作将其组合起来。</p>

<p>30.用 <code class="highlighter-rouge">NS_ENUM</code> 与 <code class="highlighter-rouge">NS_OPTIONS</code> 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</p>

<p>31.我们总习惯在 <code class="highlighter-rouge">switch</code> 语句中加上 <code class="highlighter-rouge">default</code> 分支。然而，若是用枚举来定义状态机，则最好不要有 <code class="highlighter-rouge">default</code> 分支。这样的话，如果稍后又加了一种状态，那么编译器就会发出警告信息，提示新加入的状态并未在 <code class="highlighter-rouge">switch</code> 分支中处理。假如写上了 <code class="highlighter-rouge">default</code> 分支，那么它就会处理这个新状态，从而导致编译器不发警告信息。</p>

<p>32.枚举分为：普通枚举(<code class="highlighter-rouge">NS_ENUM</code>) 和 选项枚举（<code class="highlighter-rouge">NS_OPTIONS</code>），其中选项枚举，如系统中的 <code class="highlighter-rouge">UIViewAutoresizing</code>，这么定义:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {
    UIViewAutoresizingNone                 = 0,
    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,
    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,
    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,
    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,
    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,
    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5
};
</code></pre></div></div>

<p>选项枚举的原理，见下图：</p>

<p><img src="/images//effective_objectivec_2.0/0.jpg" alt="0.jpg" /></p>

	  ]]></description>
	</item>

	<item>
	  <title>聊聊 GCD</title>
	  <link>//liao-liao-gcd</link>
	  <author></author>
	  <pubDate>2016-01-21T00:10:24+08:00</pubDate>
	  <guid>//liao-liao-gcd</guid>
	  <description><![CDATA[
	     <h2 id="什么是-gcd">什么是 GCD</h2>

<p>GCD ( Grand Central Dispatch ) 是 iOS 多任务的核心。在 Mac OS X 10.6 雪豹中首次推出，后被引入到了 iOS 4.0 中。GCD 是基于 C 的 API，是底层的框架，<code class="highlighter-rouge">NSOperationQueue</code> 是在 GCD 的基础上实现的。</p>

<p>GCD 和 Block 的配合使用，可以方便地进行多线程编程。</p>

<h2 id="gcd-包含什么内容">GCD 包含什么内容</h2>

<p>分派队列（ Dispatch Queue ），分派组（ Dispatch Group ），分派屏障（ Dispatch Barrier ）。</p>

<p>除了上面几个比较常用的 GCD 还包含下面几个内容：</p>

<p>分派信号量（ Dispatch Semaphores ）、分派源（ Dispatch Sources ）、分派数据（ Dispatch Data ）以及分派 I/O 。</p>

<p>本文仅介绍分派队列，分派组，分派屏障 GCD 等常用内容。</p>

<h2 id="同步异步并行串行并行并发-概念">同步、异步，并行、串行，并行、并发 概念</h2>

<h4 id="同步">同步</h4>

<p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p>

<p>同步代码如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_sync(concurrentQueue, ^(){
   NSLog(@"A");
});

dispatch_sync(concurrentQueue, ^(){
   NSLog(@"B");
});

// 先输出 A 后输出 B 。
</code></pre></div></div>

<h4 id="异步">异步</h4>

<p>异步的概念和同步相对。当一个异步过程调用发出后，不等待返回结果就执行下面的功能。</p>

<p>异步代码如下：</p>

<pre><code class="language-C">dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_async(concurrentQueue, ^(){
   NSLog(@"A");
});

dispatch_async(concurrentQueue, ^(){
   NSLog(@"B");
});

// 可能先输出 A 后输出 B ，也可能先输出 B 后输出 A。因为异步下是没执行完就执行下面的功能
</code></pre>

<h4 id="并行与并发区别">并行与并发区别</h4>

<p>当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态.这种方式我们称之为并发（ Concurrent ）。</p>

<p>当系统有一个以上 CPU 时,则线程的操作有可能非并发.当一个 CPU 执行一个线程时,另一个CPU 可以执行另一个线程,两个线程互不抢占 CPU 资源,可以同时进行,这种方式我们称之为并行（ Parallel ）。</p>

<h2 id="分配队列">分配队列</h2>

<p>串行队列（一个队列一个队列的执行）：</p>

<ul>
  <li>
    <p>主队列。最常见的串行队列。通过 <code class="highlighter-rouge">dispatch_get_main_queue()</code> 获得。</p>
  </li>
  <li>
    <p>自己创建的串行队列。</p>

    <pre><code class="language-C">dispatch_queue_t serialQueue = dispatch_queue_create("me.iYiming.serialQueue", DISPATCH_QUEUE_SERIAL);
</code></pre>

    <p>或者</p>

    <pre><code class="language-C">dispatch_queue_t serialQueue = dispatch_queue_create("me.iYiming.serialQueue", NULL);
</code></pre>
  </li>
</ul>

<p>并发队列（几个队列 “同时” 执行）：</p>

<ul>
  <li>
    <p>系统队列</p>

    <pre><code class="language-C">#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高
#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认
#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低
#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN //最低
</code></pre>

    <pre><code class="language-C">dispatch_queue_t concurrentQueue = dispatch_get_global_queue(XXXX, 0); // 并发队列  XXXX 表示 上面的四个参数，
</code></pre>
  </li>
  <li>
    <p>自己创建的并发队列</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dispatch_queue_t concurrentQueue = dispatch_queue_create("me.iYiming.concurrentQueue", DISPATCH_QUEUE_CONCURRENT);
</code></pre></div>    </div>
  </li>
</ul>

<p>补充：</p>

<p><code class="highlighter-rouge">dispatch_set_target_queue()</code> 用法：</p>

<p>设置自己创建队列的目标队列，使创建的队列优先级和目标队列一样。</p>

<p><a href="http://blog.csdn.net/growinggiant/article/details/41077221">http://blog.csdn.net/growinggiant/article/details/41077221</a></p>

<p>上文中说了种情况：</p>

<blockquote>
  <p>一般都是把一个任务放到一个串行的 Queue 中，如果这个任务被拆分了，被放置到<strong>多个串行的 Queue 中</strong>，但实际还是需要这个任务同步执行，那么就会有问题，因为多个串行 Queue 之间是并行的。</p>

  <p>那该如何是好呢？</p>

  <p>这是就可以使用 <code class="highlighter-rouge">dispatch_set_target_queue</code> 了。
如果将多个串行的 Queue 使用 <code class="highlighter-rouge">dispatch_set_target_queue</code> 指定到了同一目标，那么着多个串行 Queue 在目标 Queue 上就是同步执行的，不再是并行执行。</p>
</blockquote>

<p>除了上面链接中说到的用处外（也可以用别的方式替代），感觉没多大用处？！</p>

<h2 id="分配组">分配组</h2>

<p>关于使用分配组，我用到的情况就是这个情形下：执行 A 任务, B 任务后(A、B 任务可以同时做)，最后再做 C 任务。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dispatch_queue_t concurrentQueue = dispatch_queue_create("me.iYiming.concurrentQueue", DISPATCH_QUEUE_CONCURRENT);

dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, concurrentQueue, ^{
   // A 任务
});

dispatch_group_async(group, concurrentQueue, ^{
   // B 任务
});

dispatch_group_notify(group, concurrentQueue, ^{
   // C 任务
});
</code></pre></div></div>

<h2 id="分配屏障">分配屏障</h2>

<p>我们使用分配屏障会等当前队列前面处理全部执行结束后，再将指定的处理追加到该队列上，然后再由分配屏障追加的处理执行完毕后，当前队列才恢复为一般的动作，追加到该队列的处理又开始执行。</p>

<h4 id="代码">代码</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dispatch_queue_t myQueue = dispatch_get_global_queue(0, 0);
   
dispatch_async(myQueue, ^{
   NSLog(@"123");
});

dispatch_async(myQueue, ^{
   NSLog(@"456");
});

dispatch_barrier_async(myQueue, ^{
   NSLog(@"789");
});

dispatch_async(myQueue, ^{
   NSLog(@"10");
});
</code></pre></div></div>

<p>输出结果，先输出 <code class="highlighter-rouge">123</code> 或者 <code class="highlighter-rouge">456</code>，再输出 <code class="highlighter-rouge">789</code>，最后才输出 <code class="highlighter-rouge">10</code>。</p>

<h4 id="举个例子">举个例子</h4>

<p>我们都会对数据进行读写操作，为了防止多个线程对数据进行安全访问。我们需要使用锁来实现某种同步机制。</p>

<p>在 GCD 出现之前，有 2 种办法：</p>

<ul>
  <li>采用内置的“同步块”</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> - (void)synchronizationMethod {
      @synchronized(self) {
          // 使用同步块
      }
  }
</code></pre></div></div>

<ul>
  <li>直接使用 <code class="highlighter-rouge">NSLock</code> 对象（也可以使用 <code class="highlighter-rouge">NSRecursiveLock</code> 这种递归锁）。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  _lock = [[NSLock alloc] init];

  - (void)synchronizationMethod {
      [_lock lock];
      //NSLock 对象方式
      [_lock unlock];
  }
</code></pre></div></div>

<blockquote>
  <p>互斥锁分为递归锁和非递归锁。</p>

  <p>同一个线程可以多次获取同一个递归锁，不会产生死锁。<br />
如果一个线程多次获取同一个非递归锁，则会产生死锁。</p>
</blockquote>

<p>这 2 种方法都很好，不过也有其缺陷。比方说：</p>

<ul>
  <li>
    <p>在极端情况下，同步块会导致死锁，另外，其效率也不见得高.</p>
  </li>
  <li>
    <p>滥用 <code class="highlighter-rouge">@sychronized(self)</code> 会很危险，因为所有同步块都会彼此抢夺同一个锁。要是有很多个属性都这么写的话，那么每个属性的同步块都要等其他所有同步块执行完毕才能执行，这也许不是我们想要的结果。</p>
  </li>
</ul>

<p>我们可以使用 “串行同步队列”，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。</p>

<pre><code class="language-C">_serialQueue = dispatch_queue_create("me.iYiming.serialQueue", DISPATCH_QUEUE_SERIAL);
        
- (NSString *)someString {
    __block NSString *localSomeString;
    
    __weak typeof(self) wakeSelf = self;
    dispatch_sync(_serialQueue, ^{
        localSomeString = wakeSelf.someString;
    });
    return localSomeString;
}

- (void)setSomeString:(NSString *)someString {
    __weak typeof(self) wakeSelf = self;
    dispatch_sync(_serialQueue, ^{
        wakeSelf.someString = someString;
    });
}
</code></pre>

<p>还可以进一步优化。设置方法并不一定非得是同步的。设置实例变量所用的块，并不需要向设置返回什么值。也就是可以修改成如下：</p>

<pre><code class="language-C">- (void)setSomeString:(NSString *)someString {
    __weak typeof(self) wakeSelf = self;
    dispatch_async(_serialQueue, ^{
        wakeSelf.someString = someString;
    });
}
</code></pre>

<p>但经过测试一下程序性能，那么可能会发现这种写法比原来慢，因为执行异步派发时，需要拷贝块。若拷贝所用的时间明显超过执行块所花的时间，则这种做法将比原来更慢。</p>

<p>多个获取方法可以并发执行，而获取方法与设置方法之间不能并发执行，利用这个特点，还能写出更快一些的代码来。</p>

<pre><code class="language-C">_concurrentQueue = dispatch_queue_create("me.iYiming.concurrentQueue", DISPATCH_QUEUE_CONCURRENT);

- (NSString *)someString {
    __block NSString *localSomeString;
    
    __weak typeof(self) wakeSelf = self;
    dispatch_sync(_concurrentQueue, ^{
        localSomeString = wakeSelf.someString;
    });
    return localSomeString;
}

- (void)setSomeString:(NSString *)someString {
    __weak typeof(self) wakeSelf = self;
    dispatch_barrier_sync(_concurrentQueue, ^{ // 同步屏障
        wakeSelf.someString = someString;
    });
}
</code></pre>

<p><strong>使用并发队列和分配屏障可实现高效率的数据库访问和文件访问。</strong></p>

<h2 id="gcd-vs-nsoperation">GCD VS NSOperation</h2>

<p>GCD 的优点：</p>

<ol>
  <li>GCD 提供的 <code class="highlighter-rouge">dispatch_after</code> 支持调度下一个操作的开始时间而不是直接进入睡眠。</li>
  <li><code class="highlighter-rouge">NSOperation</code> 中没有类似 <code class="highlighter-rouge">dispatch_source_t</code> , <code class="highlighter-rouge">dispatch_io</code> , <code class="highlighter-rouge">dispatch_data_t</code> , <code class="highlighter-rouge">dispatch_semaphore_t</code> 等操作。</li>
</ol>

<p><code class="highlighter-rouge">NSOperation</code> 的优点：</p>

<ol>
  <li>GCD 没有操作依赖。我们可以让一个 Operation 依赖于另一个 Operation，这样的话尽管两个 Operation 处于同一个并行队列中，但前者会等后者执行完毕后再执行；</li>
  <li>GCD 没有操作优先级（ GCD 有队列优先级），能够使同一个并行队列中的任务区分先后地执行，而在 GCD 中，我们只能区分不同任务队列的优先级，如果要区分 Block 任务的优先级，也需要大量的复杂代码；</li>
  <li>GCD 没有 KVO。<code class="highlighter-rouge">NSOperation</code> 可以监听一个 Operation 是否完成或取消，这样能比 GCD 更加有效地掌控我们执行的后台任务</li>
  <li>在 <code class="highlighter-rouge">NSOperationQueue</code> 中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而 GCD 没法停止已经加入 Queue 的 Block(其实是有的，但需要许多复杂的代码)</li>
  <li>我们能够对 <code class="highlighter-rouge">NSOperation</code> 进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将 Block 任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li>
</ol>

<h2 id="使用-dispatch_once-创建单例">使用 <code class="highlighter-rouge">dispatch_once</code> 创建单例</h2>

<p>直接上代码：</p>

<pre><code class="language-C">  //保存单例对象的静态全局变量
  static id _instance;
  + (instancetype)sharedTools {
      return [[self alloc] init];
  }
  
  //在调用 alloc 方法之后，最终会调用 allocWithZone 方法
  + (instancetype)allocWithZone:(struct _NSZone *)zone {
      //保证分配内存的代码只执行一次
      static dispatch_once_t onceToken;
      dispatch_once(&amp;onceToken, ^{
          _instance = [super allocWithZone:zone];
      });
      return _instance;
  }
  
  //这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行
  - (id)copyWithZone:(NSZone *)zone {
      return self;
  }
  
  //这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行
  - (id)mutableCopyWithZone:(NSZone *)zone {
      return self;
  }
  
  #if __has_feature(objc_arc)
  //如果是ARC环境
  #else
  //如果不是 ARC 环境

  //既然是单例对象，总不能被人给销毁了吧，一旦销毁了，分配内存的代码已经执行过了，就再也不能创建对象了。所以覆盖掉release操作
  - (oneway void)release {
  
  }
  
  //这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行
  - (instancetype)retain {
      return self;
  }
  
  //为了便于识别，这里返回 MAXFLOAT ，别的程序员看到这个数据，就能意识到这是单例了。纯属装逼……
  - (NSUInteger)retainCount {
      return MAXFLOAT;
  }
  #endif
</code></pre>

<p>当然还有种方式 是使用上面那种 使用 <code class="highlighter-rouge">@synchronized()</code> 方式。但 <code class="highlighter-rouge">dispatch_once</code> 更高效，它没有使用重量级的同步机制，若是那样做的话，每次运行代码前都要获取锁，相反，此函数采用 “原子访问” 来查询标记，以判断其所对应的代码原来是否已经执行过。</p>

<h2 id="参考文章">参考文章</h2>

<p><a href="http://www.cnblogs.com/NickyYe/archive/2008/12/01/1344802.html">http://www.cnblogs.com/NickyYe/archive/2008/12/01/1344802.html</a></p>

<p><a href="http://www.tanhao.me/pieces/616.html/">http://www.tanhao.me/pieces/616.html/</a></p>

<p><a href="http://blog.csdn.net/likendsl/article/details/8568961">http://blog.csdn.net/likendsl/article/details/8568961</a></p>

<p><a href="http://stackoverflow.com/questions/15629696/why-my-completionblock-never-gets-called-in-an-nsoperation">http://stackoverflow.com/questions/15629696/why-my-completionblock-never-gets-called-in-an-nsoperation</a></p>

<p><a href="http://blog.csdn.net/hufengvip/article/details/11687699">http://blog.csdn.net/hufengvip/article/details/11687699</a></p>

<p><a href="http://www.jianshu.com/p/d09e2638eb27">http://www.jianshu.com/p/d09e2638eb27</a></p>

<p><a href="http://stackoverflow.com/questions/7651551/why-should-i-choose-gcd-over-nsoperation-and-blocks-for-high-level-applications">http://stackoverflow.com/questions/7651551/why-should-i-choose-gcd-over-nsoperation-and-blocks-for-high-level-applications</a></p>

	  ]]></description>
	</item>


</channel>
</rss>
