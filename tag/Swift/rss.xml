<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>jekyller.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>Stay hungry, stay foolish.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>A Swift Tour</title>
	  <link>//A-Swift-Tour</link>
	  <author></author>
	  <pubDate>2018-10-24T08:13:54+08:00</pubDate>
	  <guid>//A-Swift-Tour</guid>
	  <description><![CDATA[
	     <p>1.打印 Hello, world!</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Hello, world!")
</code></pre></div></div>

<ul>
  <li>不需要引入第三方的库</li>
  <li>不需要一个 <code class="highlighter-rouge">main</code> 函数</li>
  <li>不需要在结尾处写分号</li>
</ul>

<h2 id="简单值">简单值</h2>

<p>1.使用 <code class="highlighter-rouge">let</code> 声明常量。</p>

<p>2.使用 <code class="highlighter-rouge">var</code> 声明变量。</p>

<p>3.通常不需要明确指定常量、变量类型，可以让编译器推测它的类型。</p>

<p>4.如果初始值不能够提供足够的信息（或者没有初始化值），使用 <code class="highlighter-rouge">: 类型</code> 的方式来指定类型。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let implicitDouble = 70.0
let explicitDouble: Double = 70
</code></pre></div></div>

<p>5.值不能隐式的将一个类型转化为另一种类型。如果想转化为另一种类型，应明确设置。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let label = “The width is ”
let width = 94
let widthLabel = label + String(width)
</code></pre></div></div>

<p>6.有一种简单的方式将数字转换为字符串：写在一个括号里，在括号前加一个反斜杠。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples."
let fuitSummary = "I have \(apples + oranges) pieces of fruit."
</code></pre></div></div>

<p>7.使用三个双引号来承载多行字符串。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let quotation = """
Even though there's whitespace to the left,
the actual lines aren't indented.
Except for this line.
Double quotes (") can appear without being escaped.

I still have \(apples + oranges) pieces of fruit.
"""
</code></pre></div></div>

<p>8.创建数组和字典使用方括号 <code class="highlighter-rouge">[]</code> ，在 <code class="highlighter-rouge">[]</code> 中使用索引或键访问元素。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var shoppingList = ["catfish", “water”, “tulips”]
shoppingList[1] = “bottle of water”

var occupations = [
  “Malcolm”: “Captain”,
  “Kaylee”: “Mechanic”,
]
occupations[“Jayne”] = “Public Relations”
</code></pre></div></div>

<p>9.当添加元素时数组会自动扩充。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shoppingList.append(“blue paint”)
print(shoppingList)
</code></pre></div></div>

<p>10.创建一个空数组或字典，使用初始化语法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let emptyArray = [String]()
let emptyDictionary = [String: Float]()
</code></pre></div></div>

<h2 id="控制流">控制流</h2>

<p>1.使用 <code class="highlighter-rouge">if</code> 和 <code class="highlighter-rouge">switch</code> 来做判断。</p>

<p>2.使用 <code class="highlighter-rouge">for-in</code>, <code class="highlighter-rouge">while</code>, 和 <code class="highlighter-rouge">repeat-while</code> 来循环。</p>

<p>3.围绕条件判断、循环变量的圆括号是可以省略的。</p>

<p>4.可选值绑定。如果可选值是 <code class="highlighter-rouge">nil</code>，则条件是 <code class="highlighter-rouge">false</code>；如果可选值是存在的，则将这个值付给 <code class="highlighter-rouge">let</code> 后的变量，添加为 <code class="highlighter-rouge">true</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var optionalName: String? = “John Appleseed”
var greeting = “Hello!”
if let name = optionalName {
    greeting = “Hello, \(name)”
}
</code></pre></div></div>

<p>5.另一种方式处理可选类型是通过使用 <code class="highlighter-rouge">??</code> 操作符来提供默认值。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let nickName: String? = nil
let fulName: String = “John Appleseed”
let informalGreeting = “Hi \(nickName ?? fullName)”
</code></pre></div></div>

<p>6.<code class="highlighter-rouge">switch case</code> 支持各种类型的数据和各种比较操作——不限于整形和相等的比较</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let vegetable = “red pepper”
switch vegetable {
case “celery”:
    print(“Add some raisins and make ants on a log.”)
case “cucumber”, “watercress”:
    print(“That would make a good tea sandwich.”)
case let x where x.hasSuffix(“pepper”):
    print(“Is it a spicy \(x)?”)
default:
    print(“Everything tastes good in soup.”)
}
</code></pre></div></div>

<p>7.当 <code class="highlighter-rouge">switch case</code> 符合要求，程序将会从该 <code class="highlighter-rouge">case</code> 退出，执行不会继续到下一个 <code class="highlighter-rouge">case</code>。因此没必要明确在每一个 <code class="highlighter-rouge">case</code> 后面写 <code class="highlighter-rouge">break</code>。</p>

<p>8.通过提供一对名字来用于每个 key-value 对， 用于 for-in 迭代 Dictionary 中的的项。字典是无序的集合，因此他们的键值在迭代时是任意的。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let interertingNumbers = [
    “Prime”: [2, 3, 5, 7, 11, 13],
    “Fibonacci”: [1, 1, 2, 3, 5, 8], 
     “Square”: [1, 4, 9, 16, 25]
]
var largest = 0
for (kind, numbers) in interestingNumbers {
    for number in numbers {
        if number &gt; largest {
            largest = number
        }
    }
}
print(largest)
</code></pre></div></div>

<p>9.使用 <code class="highlighter-rouge">while</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var n = 2
while n &lt; 100 {
    n *= 2
}
// Prints “128”
</code></pre></div></div>

<p>10.使用 <code class="highlighter-rouge">repeat-while</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var m = 2
repeat {
    m *= 2
} while m &lt; 100
print(m)
// Prints “128”
</code></pre></div></div>

<p>11.使用 <code class="highlighter-rouge">..&lt;</code> 创建一个忽略了最大值的范围，使用 <code class="highlighter-rouge">…</code> 创建了一个包含所有值的范围。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var total = 0
for i in 0..&lt;4 {
    total += i
}
print(total)
// Prints “6”
</code></pre></div></div>

<h2 id="函数和闭包">函数和闭包</h2>

<p>1.使用 <code class="highlighter-rouge">func</code> 来定义函数。</p>

<p>2.<code class="highlighter-rouge">funcName(parameterName)</code> 来调用函数。</p>

<p>3.使用 <code class="highlighter-rouge">-&gt;</code> 来分割参数和返回类型。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func greet(person: String, day: String) -&gt; String {
    return “Hello \(person), today is \(day).”
}
greet(person: “Bob”, day: “Tuesday”)
</code></pre></div></div>

<p>4.在默认情况下，函数使用参数名来作为参数的标签。</p>

<p>5.自定义参数标签写在参数名前面。</p>

<p>6.如果没有参数标签，使用 <code class="highlighter-rouge">_</code> 代替。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func greet(_ person: String, on day: String) -&gt; String {
    return “Hello \(person), today is \(day).”
}
greet(“John”, on: “Wednesday”)
</code></pre></div></div>

<p>7.函数可以使用元组作为返回值，用于返回多个值。</p>

<p>8.函数可以嵌套在函数中。嵌套的函数可以访问嵌套外的变量。可以使用嵌套函数来组织长或者复杂的函数代码。</p>

<p>9.函数是一等类型。这意味着函数可以作为另一个函数的返回值</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func makIncrementer() -&gt;((Int) -&gt; Int) {
    func addOne(number: Int) -&gt; Int {
         return 1 + number
    }

    return addOne
}
var increment = makeIncrementer()
increment(7)
</code></pre></div></div>

<p>10.函数可以用来作为另一个函数的参数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool {
   for item in list {
         if condition(item) {
             return true
         }
    }
    return false
}
func lessThanTen(number: Int) -&gt; Bool {
    return number &lt; 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
</code></pre></div></div>

<p>11.函数事实上是一种特殊的闭包——后续会被调用的一块代码。</p>

<p>12.使用 <code class="highlighter-rouge">{}</code> 创建一个没有名字的闭包。使用 <code class="highlighter-rouge">in</code> 来分割参数、返回值和函数主体。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>numbers.map({ (number: Int) -&gt; Int in
    let result = 3 * number
    return result
})
</code></pre></div></div>

<p>13.单行声明闭包 隐式返回 仅有声明的值。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let mappedNumbers = numbers.map({ number in 3 * number })
</code></pre></div></div>

<p>14.还可以使用数字来代替参数名字。</p>

<p>15.如果函数的最后一个参数是闭包，它可以写在 <code class="highlighter-rouge">()</code> 外面。当闭包是函数的唯一一个参数，<code class="highlighter-rouge">()</code> 可以忽略。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let sortedNumber = number.sorted { $0 &gt; $1 }
print(sortedNumbers)
</code></pre></div></div>

<h2 id="对象和类">对象和类</h2>

<p>1.用 <code class="highlighter-rouge">class ClassName</code> 的方法来创建类。</p>

<p>2.类中常量、变量的声明和往常一样。同样的，方法和函数的声明也和往常一样。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Shape {
    var numberOfSides = 0
    func simpleDescription() -&gt; String {
         return “A shape with \(numberOfSides) sides.”
    }
}
</code></pre></div></div>

<p>3.创建类的实例。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var shape = Shape()
</code></pre></div></div>

<p>4.使用点语法来访问实例的属性和方法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></pre></div></div>

<p>5.上面版本的 <code class="highlighter-rouge">Shape</code> 类没有初始化器——当实例创建时用于装配类。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class NamedShape {
    var numberOfSides: Int = 0
    var name: String

     init(name: String) {
         self.name = name
     }

     func simpleDescription() -&gt; String {
          return “A shape with \(numberOfSides) sides.”
     }
}
</code></pre></div></div>

<p>6.初始化器参数传递和函数类似。</p>

<p>7.每一个属性都需要初始化——无论是在声明时，还是在初始化器里。</p>

<p>8.想在对象被释放前做一些清理操作，使用 <code class="highlighter-rouge">deinit</code> 来创建析构器。</p>

<p>9.子类继承父类使用 <code class="highlighter-rouge">:</code>。</p>

<p>10.子类的方法可以重载父类的实现，需要使用 <code class="highlighter-rouge">override</code> 标识。父类中有此方法，子类如果没有 <code class="highlighter-rouge">override</code> 使用此方法，编译器将会报错。如果父类没有此方法，子类还使用 <code class="highlighter-rouge">override</code> ，编译器也会报错。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Square: NameShape {
    var sideLength: Double

    init(sideLength: Double, name: String) {
         self.sideLength = sideLength
         super.init(name: name)
         numberOfSides = 4
    }

    func area() -&gt; Double {
        return sideLength * sideLength
    }

    override func simpleDescription() -&gt; String {
        return “A square with sides of length \(sideLength).” 
    } 
}
let test = Square(sideLength: 5.2, name: “my test square”)
test.area()
test.simpleDescription()
</code></pre></div></div>

<p>11.除了简单的用于存储的属性，属性还可以有 <code class="highlighter-rouge">getter</code> 和 <code class="highlighter-rouge">setter</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
     }

     var perimeter: Double {
         get {
             return 3.0 * sideLength
          }
          set {
              sideLength = newValue / 3.0 
          }
     }

    override func simpleDescription() -&gt; String {
         return “An equilateral triangle with sides of length \(sideLength).”
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: “a triangle”)
print(triangle.perimeter)
// Prints “9.3”
triangle.perimeter = 9.9
print(triangle.sideLength)
// Prints “3.3000000000000003”
</code></pre></div></div>

<p>12.在 <code class="highlighter-rouge">perimeter</code> 的 <code class="highlighter-rouge">setter</code> 中，新的值有一个隐式的名字 <code class="highlighter-rouge">newValue</code>。你可以在 <code class="highlighter-rouge">set</code> 后加上 <code class="highlighter-rouge">()</code>，并在 <code class="highlighter-rouge">()</code> 里明确的提供一个名字。</p>

<p>13.注意到 <code class="highlighter-rouge">EquilateralTriangle</code> 类的初始化器有 3 个不同的步骤：
（1）设置子类定义属性的值
（2）调用父类的初始化器
（3）修改父类定义的属性值。任何额外的设置工作——使用方法、getters、setter，也在这个时机操作</p>

<p>14.使用 <code class="highlighter-rouge">willSet</code> 和 <code class="highlighter-rouge">didSet</code>。</p>

<p>15.当操作可选值时，如果在 <code class="highlighter-rouge">?</code> 前的值是 <code class="highlighter-rouge">nil</code>，任何在 <code class="highlighter-rouge">?</code> 后的操作将会被忽略，整个表达式的值为 <code class="highlighter-rouge">nil</code>。否则，可选值被解开，<code class="highlighter-rouge">?</code> 后的操作作用于打开的值。在所有情况下，整个表达式的值是一个可选类型的值。</p>

<h2 id="枚举和结构体">枚举和结构体</h2>

<p>1.使用 <code class="highlighter-rouge">enum</code> 来创建枚举。</p>

<p>2.枚举中可以包含方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum Rank: Int {
    case ace = 1
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king
    
    func simpleDescription() -&gt; String {
        switch self {
            case .ace:
                return "ace"
            case .jack:
                return "jack"
            case .queen:
                return "queen"
            case .king:
                return "king"
            default:
                return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
</code></pre></div></div>

<p>3.By default, Swift assigns the raw values starting at zero and incrementing by one each time, but you can change this behavior by explicitly specifying values. In the example above, Ace is explicitly given a raw value of 1, and the rest of the raw values are assigned in order. You can also use strings or floating-point numbers as the raw type of an enumeration. Use the rawValue property to access the raw value of an enumeration case.</p>

<p>4.Use the <code class="highlighter-rouge">init?(rawValue:)</code> initializer to make an instance of an enumeration from a raw value. It returns either the enumeration case matching the raw value or nil if there is no matching Rank.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if let convertedRank = Rank(rawValue: 3) {
    let threeDescription = convertedRank.simpleDescription()
}
</code></pre></div></div>

<p>5.The case values of an enumeration are actual values, not just another way of writing their raw values. In fact, in cases where there isn’t a meaningful raw value, you don’t have to provide one.</p>

<p>6.代码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum ServerResponse {
    case result(String, String)
    case failure(String)
}

let success = ServerResponse.result("6:00 am", "8:09 pm")
let failure = ServerResponse.failure("Out of cheese.")

switch success {
    case let .result(sunrise, sunset):
        print("Sunrise is at \(sunrise) and sunset is at \(sunset).")
    case let .failure(message):
        print("Failure...  \(message)")
}
// Prints "Sunrise is at 6:00 am and sunset is at 8:09 pm."
</code></pre></div></div>

<p>7.使用 <code class="highlighter-rouge">struct</code> 来创建结构体。结构体像类一样支持很多特性，包括方法和初始化器。类和结构体最大的不同是，结构体在传递时经常会被拷贝出一个副本，但类在传递时使用引用。</p>

<h2 id="协议和扩展">协议和扩展</h2>

<p>1.使用 <code class="highlighter-rouge">protocol</code> 声明一个协议</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
</code></pre></div></div>

<p>2.类、枚举和结构体都可以适配协议</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class SimpleClass: ExampleProtocol {
    var simpleDescription: String = "A very simple class."
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "  Now 100% adjusted."
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription

struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = "A simple structure"
    mutating func adjust() {
        simpleDescription += " (adjusted)"
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
</code></pre></div></div>

<p>3.Notice the use of the <code class="highlighter-rouge">mutating</code> keyword in the declaration of SimpleStructure to mark a method that modifies the structure. The declaration of SimpleClass doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.</p>

<p>4.Use extension to add functionality to an existing type, such as new methods and computed properties. You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension Int: ExampleProtocol {
    var simpleDescription: String {
        return "The number \(self)"
    }
    mutating func adjust() {
        self += 42
    }
}
print(7.simpleDescription)	// Prints "The number 7"
</code></pre></div></div>

<p>5.You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol. When you work with values whose type is a protocol type, methods outside the protocol definition are not available.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let protocolValue: ExampleProtocol = a
print(protocolValue.simpleDescription)
// Prints "A very simple class.  Now 100% adjusted."
// print(protocolValue.anotherProperty)  // Uncomment to see the error
</code></pre></div></div>

<p>6.Even though the variable <code class="highlighter-rouge">protocolValue</code> has a runtime type of <code class="highlighter-rouge">SimpleClass</code>, the compiler treats it as the given type of <code class="highlighter-rouge">ExampleProtocol</code>. This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.</p>

<h2 id="错误处理">错误处理</h2>

<p>1.You represent errors using any type that adopts the <code class="highlighter-rouge">Error</code> protocol.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum PrinterError: Error {
    case outOfPaper
    case noToner
    case onFire
}
</code></pre></div></div>

<p>2.Use throw to throw an error and throws to mark a function that can throw an error. If you throw an error in a function, the function returns immediately and the code that called the function handles the error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func send(job: Int, toPrinter printerName: String) throws -&gt; String {
    if printerName == "Never Has Toner" {
        throw PrinterError.noToner
    }
    return "Job sent"
 }
</code></pre></div></div>

<p>3.There are several ways to handle errors. One way is to use do-catch. Inside the doblock, you mark code that can throw an error by writing try in front of it. Inside the catch block, the error is automatically given the name error unless you give it a different name.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> do {
    let printerResponse = try send(job: 1040, toPrinter: "Bi Sheng")
    print(printerResponse)
    } catch {
        print(error)
    }
    // Prints "Job sent"
</code></pre></div></div>

<p>4.You can provide multiple catch blocks that handle specific errors. You write a pattern after catch just as you do after case in a switch.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do {
    let printerResponse = try send(job: 1440, toPrinter: "Gutenberg")
    print(printerResponse)
} catch PrinterError.onFire {
    print("I'll just put this over here, with the rest of the fire.")
} catch let printerError as PrinterError {
    print("Printer error: \(printerError).")
} catch {
    print(error)
}
// Prints "Job sent"
</code></pre></div></div>

<p>5.Another way to handle errors is to use <code class="highlighter-rouge">try?</code> to convert the result to an optional. If the function throws an error, the specific error is discarded and the result is nil. Otherwise, the result is an optional containing the value that the function returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let printerSuccess = try? send(job: 1884, toPrinter: "Mergenthaler")
let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner")
</code></pre></div></div>

<p>6.Use <code class="highlighter-rouge">defer</code> to write a block of code that is executed after all other code in the function, just before the function returns. The code is executed regardless of whether the function throws an error. You can use defer to write setup and cleanup code next to each other, even though they need to be executed at different times.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var fridgeIsOpen = false
let fridgeContent = ["milk", "eggs", "leftovers"]

func fridgeContains(_ food: String) -&gt; Bool {
    fridgeIsOpen = true
    defer {
        fridgeIsOpen = false
    }
    
    let result = fridgeContent.contains(food)
    return result
}

fridgeContains("banana")
print(fridgeIsOpen)
// Prints "false"
</code></pre></div></div>

<h2 id="泛型">泛型</h2>

<p>1.Write a name inside angle brackets to make a generic function or type.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func makeArray&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] {
    var result = [Item]()
    for _ in 0..&lt;numberOfTimes {
        result.append(item)
    }
	return result
  }
makeArray(repeating: "knock", numberOfTimes: 4)
</code></pre></div></div>

<p>2.You can make generic forms of functions and methods, as well as classes, enumerations, and structures.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Reimplement the Swift standard library's optional type
enum OptionalValue&lt;Wrapped&gt; {
    case none
    case some(Wrapped)
}
var possibleInteger: OptionalValue&lt;Int&gt; = .none
possibleInteger = .some(100)
</code></pre></div></div>

<p>3.Use where right before the body to specify a list of requirements—for example, to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool
    where T.Element: Equatable, T.Element == U.Element
{
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
     }
     return false
}
anyCommonElements([1, 2, 3], [3])
</code></pre></div></div>

<p>4.Writing <code class="highlighter-rouge">&lt;T: Equatable&gt;</code> is the same as writing <code class="highlighter-rouge">&lt;T&gt; ... where T: Equatable</code>.</p>

	  ]]></description>
	</item>


</channel>
</rss>
